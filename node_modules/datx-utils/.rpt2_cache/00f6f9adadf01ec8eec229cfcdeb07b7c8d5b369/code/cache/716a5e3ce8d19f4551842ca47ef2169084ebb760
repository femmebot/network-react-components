{"code":"import { extendObservable } from 'mobx';\r\nexport function mapItems(data, fn) {\r\n    if (data instanceof Array) {\r\n        // tslint:disable-next-line:no-unnecessary-callback-wrapper\r\n        return data.map(function (item) { return fn(item); });\r\n    }\r\n    return data === null ? null : fn(data);\r\n}\r\n/**\r\n * Flatten a 2D array to a single array\r\n *\r\n * @export\r\n * @template T\r\n * @param {Array<Array<T>>} data Arrays to flatten\r\n * @returns {Array<T>} Flattened array\r\n */\r\nexport function flatten(data) {\r\n    return (_a = []).concat.apply(_a, data);\r\n    var _a;\r\n}\r\n/**\r\n * Return a unique set of items in an array\r\n *\r\n * @export\r\n * @template T\r\n * @param {Array<T>} data Array to filter\r\n * @returns {Array<T>} Filtered array\r\n */\r\nexport function uniq(data) {\r\n    return Array.from(new Set(data));\r\n}\r\n/**\r\n * Check if the given variable is an array with at least one falsy value\r\n *\r\n * @export\r\n * @param {any} value A variable to check\r\n * @returns {boolean} The given variable is an array with at least one falsy value\r\n */\r\nexport function isFalsyArray(value) {\r\n    return value instanceof Array && !value.every(Boolean);\r\n}\r\n/**\r\n * Add a computed property to an observable object\r\n *\r\n * @export\r\n * @param {object} obj Observable object\r\n * @param {string} key Property to add\r\n * @param {() => any} getter Getter function\r\n * @param {(value: any) => void} [setter] Setter function\r\n */\r\nexport function assignComputed(obj, key, getter, setter) {\r\n    var value;\r\n    if (key in obj) {\r\n        value = obj[key];\r\n        delete obj[key];\r\n    }\r\n    if (setter) {\r\n        extendObservable(obj, (_a = {},\r\n            Object.defineProperty(_a, key, {\r\n                get: function () {\r\n                    return getter();\r\n                },\r\n                enumerable: true,\r\n                configurable: true\r\n            }),\r\n            Object.defineProperty(_a, key, {\r\n                set: function (val) {\r\n                    if (setter) {\r\n                        setter(val);\r\n                    }\r\n                },\r\n                enumerable: true,\r\n                configurable: true\r\n            }),\r\n            _a));\r\n    }\r\n    else {\r\n        extendObservable(obj, (_b = {},\r\n            Object.defineProperty(_b, key, {\r\n                get: function () {\r\n                    return getter();\r\n                },\r\n                enumerable: true,\r\n                configurable: true\r\n            }),\r\n            _b));\r\n    }\r\n    if (value !== undefined) {\r\n        obj[key] = value;\r\n    }\r\n    var _a, _b;\r\n}\r\nexport function error() {\r\n    var args = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        args[_i] = arguments[_i];\r\n    }\r\n    // tslint:disable-next-line:no-console\r\n    console.error.apply(console, [\"[datx error]\"].concat(args));\r\n}\r\nexport function warn() {\r\n    var args = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        args[_i] = arguments[_i];\r\n    }\r\n    if (process.env.NODE_ENV === 'production' || process.env.NODE_ENV === 'test') {\r\n        return;\r\n    }\r\n    // tslint:disable-next-line:no-console\r\n    console.warn.apply(console, [\"[datx warning]\"].concat(args));\r\n}\r\nexport function deprecated() {\r\n    var args = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        args[_i] = arguments[_i];\r\n    }\r\n    if (process.env.NODE_ENV === 'production' || process.env.NODE_ENV === 'test') {\r\n        return;\r\n    }\r\n    // tslint:disable-next-line:no-console\r\n    console.warn.apply(console, [\"[datx deprecated]\"].concat(args));\r\n}\r\nexport function info() {\r\n    var args = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        args[_i] = arguments[_i];\r\n    }\r\n    if (process.env.NODE_ENV === 'production' || process.env.NODE_ENV === 'test') {\r\n        return;\r\n    }\r\n    // tslint:disable-next-line:no-console\r\n    console.info.apply(console, [\"[datx info]\"].concat(args));\r\n}\r\n","dts":{"name":"/Users/darko/Projects/mobx/datx/packages/datx-utils/helpers.d.ts","text":"/**\r\n * Map a single item or an array of items\r\n *\r\n * @export\r\n * @template T\r\n * @template U\r\n * @param {(T|Array<T>)} data Data to iterate over\r\n * @param {(item: T) => U} fn Function called for every data item\r\n * @returns {(U|Array<U>|null)} Return value of the callback function\r\n */\r\nexport declare function mapItems<T, U>(data: Array<T>, fn: (item: T) => U): Array<U>;\r\nexport declare function mapItems<T, U>(data: T, fn: (item: T) => U): U | null;\r\n/**\r\n * Flatten a 2D array to a single array\r\n *\r\n * @export\r\n * @template T\r\n * @param {Array<Array<T>>} data Arrays to flatten\r\n * @returns {Array<T>} Flattened array\r\n */\r\nexport declare function flatten<T>(data: Array<Array<T>>): Array<T>;\r\n/**\r\n * Return a unique set of items in an array\r\n *\r\n * @export\r\n * @template T\r\n * @param {Array<T>} data Array to filter\r\n * @returns {Array<T>} Filtered array\r\n */\r\nexport declare function uniq<T>(data: Array<T>): Array<T>;\r\n/**\r\n * Check if the given variable is an array with at least one falsy value\r\n *\r\n * @export\r\n * @param {any} value A variable to check\r\n * @returns {boolean} The given variable is an array with at least one falsy value\r\n */\r\nexport declare function isFalsyArray(value: any): boolean;\r\n/**\r\n * Add a computed property to an observable object\r\n *\r\n * @export\r\n * @param {object} obj Observable object\r\n * @param {string} key Property to add\r\n * @param {() => any} getter Getter function\r\n * @param {(value: any) => void} [setter] Setter function\r\n */\r\nexport declare function assignComputed<T = any>(obj: object, key: string, getter: () => T, setter?: (value: T) => void): void;\r\nexport declare function error(...args: any[]): void;\r\nexport declare function warn(...args: any[]): void;\r\nexport declare function deprecated(...args: any[]): void;\r\nexport declare function info(...args: any[]): void;\r\n"}}

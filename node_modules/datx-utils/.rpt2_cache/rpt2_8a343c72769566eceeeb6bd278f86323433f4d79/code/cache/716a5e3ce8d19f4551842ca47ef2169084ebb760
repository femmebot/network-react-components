{"map":"{\"version\":3,\"file\":\"helpers.js\",\"sourceRoot\":\"\",\"sources\":[\"../../src/helpers.ts\"],\"names\":[],\"mappings\":\"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\",\"sourcesContent\":[\"import {computed, decorate, extendObservable} from 'mobx';\\n\\n/**\\n * Map a single item or an array of items\\n *\\n * @export\\n * @template T\\n * @template U\\n * @param {(T|Array<T>)} data Data to iterate over\\n * @param {(item: T) => U} fn Function called for every data item\\n * @returns {(U|Array<U>|null)} Return value of the callback function\\n */\\nexport function mapItems<T, U>(data: Array<T>, fn: (item: T) => U): Array<U>;\\nexport function mapItems<T, U>(data: T, fn: (item: T) => U): U|null;\\nexport function mapItems<T, U>(data: T|Array<T>, fn: (item: T) => U): U|Array<U>|null {\\n  if (data instanceof Array) {\\n    // tslint:disable-next-line:no-unnecessary-callback-wrapper\\n    return data.map((item) => fn(item));\\n  }\\n\\n  return data === null ? null : fn(data);\\n}\\n\\n/**\\n * Flatten a 2D array to a single array\\n *\\n * @export\\n * @template T\\n * @param {Array<Array<T>>} data Arrays to flatten\\n * @returns {Array<T>} Flattened array\\n */\\nexport function flatten<T>(data: Array<Array<T>>): Array<T> {\\n  return ([] as Array<T>).concat(...data);\\n}\\n\\n/**\\n * Return a unique set of items in an array\\n *\\n * @export\\n * @template T\\n * @param {Array<T>} data Array to filter\\n * @returns {Array<T>} Filtered array\\n */\\nexport function uniq<T>(data: Array<T>): Array<T> {\\n  return Array.from(new Set(data));\\n}\\n\\n/**\\n * Check if the given variable is an array with at least one falsy value\\n *\\n * @export\\n * @param {any} value A variable to check\\n * @returns {boolean} The given variable is an array with at least one falsy value\\n */\\nexport function isFalsyArray(value: any): boolean {\\n  return value instanceof Array && !value.every(Boolean);\\n}\\n\\n/**\\n * Add a computed property to an observable object\\n *\\n * @export\\n * @param {object} obj Observable object\\n * @param {string} key Property to add\\n * @param {() => any} getter Getter function\\n * @param {(value: any) => void} [setter] Setter function\\n */\\nexport function assignComputed<T = any>(\\n  obj: object,\\n  key: string,\\n  getter: () => T,\\n  setter?: (value: T) => void,\\n) {\\n  let value;\\n  if (key in obj) {\\n    value = obj[key];\\n    delete obj[key];\\n  }\\n\\n  if (setter) {\\n    extendObservable(obj, {\\n      get [key]() {\\n        return getter();\\n      },\\n      set [key](val) {\\n        if (setter) {\\n          setter(val);\\n        }\\n      },\\n    });\\n  } else {\\n    extendObservable(obj, {\\n      get [key]() {\\n        return getter();\\n      },\\n    });\\n  }\\n\\n  if (value !== undefined) {\\n    obj[key] = value;\\n  }\\n}\\n\\nexport function error(...args) {\\n  // tslint:disable-next-line:no-console\\n  console.error(`[datx error]`, ...args);\\n}\\n\\nexport function warn(...args) {\\n  if (process.env.NODE_ENV === 'production' || process.env.NODE_ENV === 'test') {\\n    return;\\n  }\\n\\n  // tslint:disable-next-line:no-console\\n  console.warn(`[datx warning]`, ...args);\\n}\\n\\nexport function deprecated(...args) {\\n  if (process.env.NODE_ENV === 'production' || process.env.NODE_ENV === 'test') {\\n    return;\\n  }\\n\\n  // tslint:disable-next-line:no-console\\n  console.warn(`[datx deprecated]`, ...args);\\n}\\n\\nexport function info(...args) {\\n  if (process.env.NODE_ENV === 'production' || process.env.NODE_ENV === 'test') {\\n    return;\\n  }\\n\\n  // tslint:disable-next-line:no-console\\n  console.info(`[datx info]`, ...args);\\n}\\n\"]}","code":"import { extendObservable } from 'mobx';\r\nexport function mapItems(data, fn) {\r\n    if (data instanceof Array) {\r\n        // tslint:disable-next-line:no-unnecessary-callback-wrapper\r\n        return data.map(function (item) { return fn(item); });\r\n    }\r\n    return data === null ? null : fn(data);\r\n}\r\n/**\r\n * Flatten a 2D array to a single array\r\n *\r\n * @export\r\n * @template T\r\n * @param {Array<Array<T>>} data Arrays to flatten\r\n * @returns {Array<T>} Flattened array\r\n */\r\nexport function flatten(data) {\r\n    return (_a = []).concat.apply(_a, data);\r\n    var _a;\r\n}\r\n/**\r\n * Return a unique set of items in an array\r\n *\r\n * @export\r\n * @template T\r\n * @param {Array<T>} data Array to filter\r\n * @returns {Array<T>} Filtered array\r\n */\r\nexport function uniq(data) {\r\n    return Array.from(new Set(data));\r\n}\r\n/**\r\n * Check if the given variable is an array with at least one falsy value\r\n *\r\n * @export\r\n * @param {any} value A variable to check\r\n * @returns {boolean} The given variable is an array with at least one falsy value\r\n */\r\nexport function isFalsyArray(value) {\r\n    return value instanceof Array && !value.every(Boolean);\r\n}\r\n/**\r\n * Add a computed property to an observable object\r\n *\r\n * @export\r\n * @param {object} obj Observable object\r\n * @param {string} key Property to add\r\n * @param {() => any} getter Getter function\r\n * @param {(value: any) => void} [setter] Setter function\r\n */\r\nexport function assignComputed(obj, key, getter, setter) {\r\n    var value;\r\n    if (key in obj) {\r\n        value = obj[key];\r\n        delete obj[key];\r\n    }\r\n    if (setter) {\r\n        extendObservable(obj, (_a = {},\r\n            Object.defineProperty(_a, key, {\r\n                get: function () {\r\n                    return getter();\r\n                },\r\n                enumerable: true,\r\n                configurable: true\r\n            }),\r\n            Object.defineProperty(_a, key, {\r\n                set: function (val) {\r\n                    if (setter) {\r\n                        setter(val);\r\n                    }\r\n                },\r\n                enumerable: true,\r\n                configurable: true\r\n            }),\r\n            _a));\r\n    }\r\n    else {\r\n        extendObservable(obj, (_b = {},\r\n            Object.defineProperty(_b, key, {\r\n                get: function () {\r\n                    return getter();\r\n                },\r\n                enumerable: true,\r\n                configurable: true\r\n            }),\r\n            _b));\r\n    }\r\n    if (value !== undefined) {\r\n        obj[key] = value;\r\n    }\r\n    var _a, _b;\r\n}\r\nexport function error() {\r\n    var args = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        args[_i] = arguments[_i];\r\n    }\r\n    // tslint:disable-next-line:no-console\r\n    console.error.apply(console, [\"[datx error]\"].concat(args));\r\n}\r\nexport function warn() {\r\n    var args = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        args[_i] = arguments[_i];\r\n    }\r\n    if (process.env.NODE_ENV === 'production' || process.env.NODE_ENV === 'test') {\r\n        return;\r\n    }\r\n    // tslint:disable-next-line:no-console\r\n    console.warn.apply(console, [\"[datx warning]\"].concat(args));\r\n}\r\nexport function deprecated() {\r\n    var args = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        args[_i] = arguments[_i];\r\n    }\r\n    if (process.env.NODE_ENV === 'production' || process.env.NODE_ENV === 'test') {\r\n        return;\r\n    }\r\n    // tslint:disable-next-line:no-console\r\n    console.warn.apply(console, [\"[datx deprecated]\"].concat(args));\r\n}\r\nexport function info() {\r\n    var args = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        args[_i] = arguments[_i];\r\n    }\r\n    if (process.env.NODE_ENV === 'production' || process.env.NODE_ENV === 'test') {\r\n        return;\r\n    }\r\n    // tslint:disable-next-line:no-console\r\n    console.info.apply(console, [\"[datx info]\"].concat(args));\r\n}\r\n//# sourceMappingURL=helpers.js.map","dts":{"name":"/Users/darko/Projects/mobx/datx/packages/datx-utils/helpers.d.ts","text":"/**\r\n * Map a single item or an array of items\r\n *\r\n * @export\r\n * @template T\r\n * @template U\r\n * @param {(T|Array<T>)} data Data to iterate over\r\n * @param {(item: T) => U} fn Function called for every data item\r\n * @returns {(U|Array<U>|null)} Return value of the callback function\r\n */\r\nexport declare function mapItems<T, U>(data: Array<T>, fn: (item: T) => U): Array<U>;\r\nexport declare function mapItems<T, U>(data: T, fn: (item: T) => U): U | null;\r\n/**\r\n * Flatten a 2D array to a single array\r\n *\r\n * @export\r\n * @template T\r\n * @param {Array<Array<T>>} data Arrays to flatten\r\n * @returns {Array<T>} Flattened array\r\n */\r\nexport declare function flatten<T>(data: Array<Array<T>>): Array<T>;\r\n/**\r\n * Return a unique set of items in an array\r\n *\r\n * @export\r\n * @template T\r\n * @param {Array<T>} data Array to filter\r\n * @returns {Array<T>} Filtered array\r\n */\r\nexport declare function uniq<T>(data: Array<T>): Array<T>;\r\n/**\r\n * Check if the given variable is an array with at least one falsy value\r\n *\r\n * @export\r\n * @param {any} value A variable to check\r\n * @returns {boolean} The given variable is an array with at least one falsy value\r\n */\r\nexport declare function isFalsyArray(value: any): boolean;\r\n/**\r\n * Add a computed property to an observable object\r\n *\r\n * @export\r\n * @param {object} obj Observable object\r\n * @param {string} key Property to add\r\n * @param {() => any} getter Getter function\r\n * @param {(value: any) => void} [setter] Setter function\r\n */\r\nexport declare function assignComputed<T = any>(obj: object, key: string, getter: () => T, setter?: (value: T) => void): void;\r\nexport declare function error(...args: any[]): void;\r\nexport declare function warn(...args: any[]): void;\r\nexport declare function deprecated(...args: any[]): void;\r\nexport declare function info(...args: any[]): void;\r\n"}}

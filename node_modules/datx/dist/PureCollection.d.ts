import { IDictionary, IRawModel } from 'datx-utils';
import { IObservableArray } from 'mobx';
import { IIdentifier } from './interfaces/IIdentifier';
import { IModelConstructor } from './interfaces/IModelConstructor';
import { IRawCollection } from './interfaces/IRawCollection';
import { IType } from './interfaces/IType';
import { TFilterFn } from './interfaces/TFilterFn';
import { PureModel } from './PureModel';
export declare class PureCollection {
    /**
     * List of models available in the collection
     *
     * @static
     * @type {Array<typeof PureModel>}
     * @memberof Collection
     */
    static types: Array<typeof PureModel | IModelConstructor>;
    static views: IDictionary<{
        modelType: IType | PureModel;
        sortMethod?: string | ((PureModel) => any);
        unique?: boolean;
        mixins?: Array<(view: any) => any>;
    }>;
    static defaultModel?: typeof PureModel;
    private __data;
    private __views;
    private __viewList;
    private __dataMap;
    private __dataList;
    constructor(data?: Array<IRawModel> | IRawCollection);
    /**
     * Function for inserting raw models into the collection. Used when hydrating the collection
     *
     * @param {Array<IRawModel>} data Raw model data
     * @returns {Array<PureModel>} A list of initialized models
     * @memberof Collection
     */
    insert(data: Array<Partial<IRawModel>>): Array<PureModel>;
    /**
     * Add an existing model to the collection
     *
     * @template T
     * @param {T} data Model to be added
     * @returns {T} Added model
     * @memberof Collection
     */
    add<T extends PureModel>(data: T): T;
    /**
     * Add an array of existing models to the collection
     *
     * @template T
     * @param {Array<T>} data Array of models to be added
     * @returns {Array<T>} Added models
     * @memberof Collection
     */
    add<T extends PureModel>(data: Array<T>): Array<T>;
    /**
     * Add an array of new models to the collection
     *
     * @template T
     * @param {Array<IRawModel|IDictionary>} data Array of new data to be added
     * @param {(IType|IModelConstructor<T>)} model Model type to be added
     * @returns {Array<T>} Added models
     * @memberof Collection
     */
    add<T extends PureModel>(data: Array<IRawModel | IDictionary>, model: IType | IModelConstructor<T>): Array<T>;
    /**
     * Add a new model to the collection
     *
     * @template T
     * @param {(IRawModel|IDictionary)} data New data to be added
     * @param {(IType|IModelConstructor<T>)} model Model type to be added
     * @returns {T} Added model
     * @memberof Collection
     */
    add<T extends PureModel>(data: IRawModel | IDictionary, model: IType | IModelConstructor<T>): T;
    /**
     * Find a model based on the defined type and (optional) identifier
     *
     * @param {(IType|typeof PureModel|PureModel)} type Model type
     * @param {IIdentifier} [id] Model identifier
     * @returns {(PureModel|null)} The first matching model
     * @memberof Collection
     */
    find<T extends PureModel>(type: IType | T | IModelConstructor<T>, id?: IIdentifier | PureModel): T | null;
    /**
     * Find a model based on a matching function
     *
     * @param {TFilterFn} test Function used to match the model
     * @returns {(PureModel|null)} The first matching model
     * @memberof Collection
     */
    find<T extends PureModel>(test: TFilterFn): T | null;
    /**
     * Filter models based on a matching function
     *
     * @param {TFilterFn} test Function used to match the models
     * @returns {(PureModel|null)} The matching models
     * @memberof Collection
     */
    filter(test: TFilterFn): Array<PureModel>;
    /**
     * Find all matching models or all models if no type is given
     *
     * @param {(IType|typeof PureModel)} [model] Model type to select
     * @returns {Array<PureModel>} List of matching models
     * @memberof Collection
     */
    findAll<T extends PureModel>(model?: IType | IModelConstructor<T>): IObservableArray<T>;
    /**
     * Check if a model is in the collection
     *
     * @param {PureModel} model Model to check
     * @returns {boolean} The given model is in the collection
     * @memberof Collection
     */
    hasItem(model: PureModel): boolean;
    /**
     * Remove the first model based on the type and (optional) identifier
     *
     * @param {(IType|typeof PureModel)} type Model type
     * @param {IIdentifier} [id] Model identifier
     * @memberof Collection
     */
    remove(type: IType | typeof PureModel, id?: IIdentifier): any;
    /**
     * Remove the given model from the collection
     *
     * @param {PureModel} model Model to be removed from the collection
     * @memberof Collection
     */
    remove(model: PureModel): any;
    /**
     * Remove all models of the given model type from the collection
     *
     * @param {(IType|typeof PureModel)} type Model type
     * @memberof Collection
     */
    removeAll(type: IType | typeof PureModel): void;
    /**
     * A total count of models in the collection
     *
     * @readonly
     * @type {number}
     * @memberof Collection
     */
    readonly length: number;
    /**
     * Get the serializable value of the collection
     *
     * @returns {IRawCollection} Pure JS value of the collection
     * @memberof Collection
     */
    toJSON(): IRawCollection;
    readonly snapshot: IRawCollection;
    /**
     * Reset the collection (remove all models)
     *
     * @memberof Collection
     */
    reset(): void;
    getAllModels(): PureModel[];
    /**
     * Add a view to the collection
     *
     * @template T Model type of the view
     * @param {string} name View name
     * @param {(IModelConstructor<T>|IType)} type Model type the view will represent
     * @param {({
     *       sortMethod?: string|((item: T) => any),
     *       models?: Array<IIdentifier|PureModel>,
     *       unique?: boolean,
     *       mixins?: Array<(view: any) => any>,
     *     })} [{sortMethod, models, unique, mixins}={}] View options
     * @returns {View} The created view
     * @memberof PureCollection
     */
    addView<T extends PureModel = PureModel>(name: string, type: IModelConstructor<T> | IType, {sortMethod, models, unique, mixins}?: {
        sortMethod?: string | ((item: T) => any);
        models?: Array<IIdentifier | T>;
        unique?: boolean;
        mixins?: Array<(view: any) => any>;
    }): any;
    private __addArray<T>(data);
    private __addArray<T>(data, model?);
    private __addSingle<T>(data);
    private __addSingle<T>(data, model?);
    private __insertModel(model, type?, id?);
    private __removeModel(model, type?, id?);
    private __findByType(model, id?);
    private __changeModelId(oldId, newId, type);
}

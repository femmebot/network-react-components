{"map":"{\"version\":3,\"file\":\"setupModel.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../src/mixins/setupModel.ts\"],\"names\":[],\"mappings\":\";AAEA,OAAO,EAAC,aAAa,EAAC,MAAM,wBAAwB,CAAC;AACrD,OAAO,EAAC,cAAc,EAAC,MAAM,WAAW,CAAC;AACzC,OAAO,EAAC,KAAK,EAAC,MAAM,mBAAmB,CAAC;AACxC,OAAO,EAAC,OAAO,EAAC,MAAM,kBAAkB,CAAC;AAIzC,OAAO,IAAI,MAAM,SAAS,CAAC;AAG3B,MAAM,qBACJ,IAA+B,EAC/B,EAa2B;QAb3B,wCAa2B,EAZzB,kBAAM,EACN,0BAAU,EACV,cAAI,EACJ,4BAAW,EACX,gCAAa;IAUf,IAAM,SAAS,GAAG,IAAwB,CAAC;IAE3C,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,EAAE;QACvB,MAAM,KAAK,CAAC,cAAc,CAAC,CAAC;KAC7B;IAED;QAA6B,0CAAS;QAAtC;;QAAwC,CAAC;QAAD,qBAAC;IAAD,CAAC,AAAzC,CAA6B,SAAS,GAAG;IAEzC,IAAI,IAAI,EAAE;QACR,cAAc,CAAC,IAAI,GAAG,IAAI,CAAC;KAC5B;IAED,IAAI,WAAW,EAAE;QACf,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,SAAS,EAAE,WAAW,CAAC,CAAC;KACxD;IAED,IAAI,aAAa,EAAE;QACjB,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,SAAS,EAAE,aAAa,CAAC,CAAC;KACpD;IAED,IAAI,MAAM,EAAE;QACV,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,OAAO,CAAC,UAAC,GAAG;YAC9B,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,cAAc,CAAC,SAAS,EAAE,GAAG,CAAC,CAAC;QAChE,CAAC,CAAC,CAAC;KACJ;IAED,IAAI,UAAU,EAAE;QACd,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,OAAO,CAAC,UAAC,GAAG;YAC5B,IAAA,oBAAmC,EAAlC,gBAAK,EAAE,sBAAQ,CAAoB;YAC1C,QAAQ,UAAU,CAAC,GAAG,CAAC,CAAC,IAAI,EAAE;gBAC5B,KAAK,aAAa,CAAC,MAAM;oBACvB,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,cAAc,CAAC,SAAS,EAAE,GAAG,CAAC,CAAC;oBAEjD,OAAO;gBACT,KAAK,aAAa,CAAC,OAAO;oBACxB,IAAI,CAAC,MAAM,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC,cAAc,CAAC,SAAS,EAAE,GAAG,CAAC,CAAC;oBAE5D,OAAO;gBACT;oBACE,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC,cAAc,CAAC,SAAS,EAAE,GAAG,CAAC,CAAC;oBAEvD,OAAO;aACV;QACH,CAAC,CAAC,CAAC;KACJ;IAED,OAAO,cAAqD,CAAC;AAC/D,CAAC\",\"sourcesContent\":[\"import {IDictionary} from 'datx-utils';\\n\\nimport {ReferenceType} from '../enums/ReferenceType';\\nimport {DECORATE_MODEL} from '../errors';\\nimport {error} from '../helpers/format';\\nimport {isModel} from '../helpers/mixin';\\nimport {IModelConstructor} from '../interfaces/IModelConstructor';\\nimport {IReferenceOptions} from '../interfaces/IReferenceOptions';\\nimport {IType} from '../interfaces/IType';\\nimport prop from '../prop';\\nimport {PureModel} from '../PureModel';\\n\\nexport function setupModel<IModel extends PureModel, IFields extends IDictionary>(\\n  Base: IModelConstructor<IModel>,\\n  {\\n    fields,\\n    references,\\n    type,\\n    idAttribute,\\n    typeAttribute,\\n  }: {\\n    fields: IFields;\\n    references?: IDictionary<IReferenceOptions>;\\n    type?: IType;\\n    idAttribute?: string;\\n    typeAttribute?: string;\\n  // tslint:disable-next-line:no-object-literal-type-assertion\\n  } = {fields: {} as IFields},\\n) {\\n  const BaseClass = Base as typeof PureModel;\\n\\n  if (!isModel(BaseClass)) {\\n    throw error(DECORATE_MODEL);\\n  }\\n\\n  class ModelWithProps extends BaseClass {}\\n\\n  if (type) {\\n    ModelWithProps.type = type;\\n  }\\n\\n  if (idAttribute) {\\n    prop.identifier(ModelWithProps.prototype, idAttribute);\\n  }\\n\\n  if (typeAttribute) {\\n    prop.type(ModelWithProps.prototype, typeAttribute);\\n  }\\n\\n  if (fields) {\\n    Object.keys(fields).forEach((key) => {\\n      prop.defaultValue(fields[key])(ModelWithProps.prototype, key);\\n    });\\n  }\\n\\n  if (references) {\\n    Object.keys(references).forEach((key) => {\\n      const {model, property} = references[key];\\n      switch (references[key].type) {\\n        case ReferenceType.TO_ONE:\\n          prop.toOne(model)(ModelWithProps.prototype, key);\\n\\n          return;\\n        case ReferenceType.TO_MANY:\\n          prop.toMany(model, property)(ModelWithProps.prototype, key);\\n\\n          return;\\n        default:\\n          prop.toOneOrMany(model)(ModelWithProps.prototype, key);\\n\\n          return;\\n      }\\n    });\\n  }\\n\\n  return ModelWithProps as IModelConstructor<IModel & IFields>;\\n}\\n\"]}","code":"import * as tslib_1 from \"tslib\";\r\nimport { ReferenceType } from '../enums/ReferenceType';\r\nimport { DECORATE_MODEL } from '../errors';\r\nimport { error } from '../helpers/format';\r\nimport { isModel } from '../helpers/mixin';\r\nimport prop from '../prop';\r\nexport function setupModel(Base, _a) {\r\n    var _b = _a === void 0 ? { fields: {} } : _a, fields = _b.fields, references = _b.references, type = _b.type, idAttribute = _b.idAttribute, typeAttribute = _b.typeAttribute;\r\n    var BaseClass = Base;\r\n    if (!isModel(BaseClass)) {\r\n        throw error(DECORATE_MODEL);\r\n    }\r\n    var ModelWithProps = /** @class */ (function (_super) {\r\n        tslib_1.__extends(ModelWithProps, _super);\r\n        function ModelWithProps() {\r\n            return _super !== null && _super.apply(this, arguments) || this;\r\n        }\r\n        return ModelWithProps;\r\n    }(BaseClass));\r\n    if (type) {\r\n        ModelWithProps.type = type;\r\n    }\r\n    if (idAttribute) {\r\n        prop.identifier(ModelWithProps.prototype, idAttribute);\r\n    }\r\n    if (typeAttribute) {\r\n        prop.type(ModelWithProps.prototype, typeAttribute);\r\n    }\r\n    if (fields) {\r\n        Object.keys(fields).forEach(function (key) {\r\n            prop.defaultValue(fields[key])(ModelWithProps.prototype, key);\r\n        });\r\n    }\r\n    if (references) {\r\n        Object.keys(references).forEach(function (key) {\r\n            var _a = references[key], model = _a.model, property = _a.property;\r\n            switch (references[key].type) {\r\n                case ReferenceType.TO_ONE:\r\n                    prop.toOne(model)(ModelWithProps.prototype, key);\r\n                    return;\r\n                case ReferenceType.TO_MANY:\r\n                    prop.toMany(model, property)(ModelWithProps.prototype, key);\r\n                    return;\r\n                default:\r\n                    prop.toOneOrMany(model)(ModelWithProps.prototype, key);\r\n                    return;\r\n            }\r\n        });\r\n    }\r\n    return ModelWithProps;\r\n}\r\n//# sourceMappingURL=setupModel.js.map","dts":{"name":"/Users/darko/Projects/mobx/datx/packages/datx/mixins/setupModel.d.ts","text":"import { IDictionary } from 'datx-utils';\r\nimport { IModelConstructor } from '../interfaces/IModelConstructor';\r\nimport { IReferenceOptions } from '../interfaces/IReferenceOptions';\r\nimport { IType } from '../interfaces/IType';\r\nimport { PureModel } from '../PureModel';\r\nexport declare function setupModel<IModel extends PureModel, IFields extends IDictionary>(Base: IModelConstructor<IModel>, {fields, references, type, idAttribute, typeAttribute}?: {\r\n    fields: IFields;\r\n    references?: IDictionary<IReferenceOptions>;\r\n    type?: IType;\r\n    idAttribute?: string;\r\n    typeAttribute?: string;\r\n}): IModelConstructor<IModel & IFields>;\r\n"}}

{"map":"{\"version\":3,\"file\":\"withMeta.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../src/mixins/withMeta.ts\"],\"names\":[],\"mappings\":\";AAAA,OAAO,EAAC,QAAQ,EAAC,MAAM,MAAM,CAAC;AAE9B,OAAO,EAAC,cAAc,EAAC,MAAM,WAAW,CAAC;AACzC,OAAO,EAAC,KAAK,EAAC,MAAM,mBAAmB,CAAC;AACxC,OAAO,EAAC,OAAO,EAAC,MAAM,kBAAkB,CAAC;AACzC,OAAO,EAAC,QAAQ,EAAC,MAAM,yBAAyB,CAAC;AACjD,OAAO,EACL,kBAAkB,EAClB,UAAU,EACV,eAAe,EACf,YAAY,EACZ,gBAAgB,EAChB,WAAW,GACZ,MAAM,wBAAwB,CAAC;AAKhC;;;;;;;GAOG;AACH,MAAM,mBAAwC,IAA0B;IACtE,IAAM,SAAS,GAAG,IAAwB,CAAC;IAE3C,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,EAAE;QACvB,MAAM,KAAK,CAAC,cAAc,CAAC,CAAC;KAC7B;IAED;QAAuB,oCAAS;QAAhC;;QAiBA,CAAC;QAhBW,sBAAW,0BAAI;iBAAf;gBAAV,iBAeC;gBAdC,IAAM,OAAO,GAAG,eAAe,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;gBAC9C,IAAM,IAAI,GAAG,EAAE,CAAC;gBAChB,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,OAAO,CAAC,UAAC,GAAG;oBAC/B,IAAI,CAAC,GAAG,CAAC,GAAG,QAAQ,CAAC,KAAI,EAAE,GAAG,CAAC,CAAC;gBAClC,CAAC,CAAC,CAAC;gBAEH,OAAO,MAAM,CAAC,MAAM,CAAC;oBACnB,UAAU,EAAE,kBAAkB,CAAC,IAAI,CAAC;oBACpC,EAAE,EAAE,UAAU,CAAC,IAAI,CAAC;oBACpB,QAAQ,EAAE,eAAe,CAAC,IAAI,EAAE,YAAY,CAAC,IAAI,gBAAgB,CAAC,IAAI,CAAC,IAAI,SAAS;oBACpF,IAAI,MAAA;oBACJ,QAAQ,EAAE,WAAW,CAAC,IAAI,CAAC;oBAC3B,IAAI,EAAE,YAAY,CAAC,IAAI,CAAC;iBACzB,CAAC,CAAC;YACL,CAAC;;;WAAA;QAfS;YAAT,QAAQ;4CAeR;QACH,eAAC;KAAA,AAjBD,CAAuB,SAAS,GAiB/B;IAED,OAAO,QAAgD,CAAC;AAC1D,CAAC\",\"sourcesContent\":[\"import {computed} from 'mobx';\\n\\nimport {DECORATE_MODEL} from '../errors';\\nimport {error} from '../helpers/format';\\nimport {isModel} from '../helpers/mixin';\\nimport {getRefId} from '../helpers/model/fields';\\nimport {\\n  getModelCollection,\\n  getModelId,\\n  getModelMetaKey,\\n  getModelType,\\n  getOriginalModel,\\n  modelToJSON,\\n} from '../helpers/model/utils';\\nimport {IMetaMixin} from '../interfaces/IMetaMixin';\\nimport {IModelConstructor} from '../interfaces/IModelConstructor';\\nimport {PureModel} from '../PureModel';\\n\\n/**\\n * Extends the model with the exposed meta data\\n *\\n * @export\\n * @template T\\n * @param {IModelConstructor<T>} Base Model to extend\\n * @returns Extended model\\n */\\nexport function withMeta<T extends PureModel>(Base: IModelConstructor<T>) {\\n  const BaseClass = Base as typeof PureModel;\\n\\n  if (!isModel(BaseClass)) {\\n    throw error(DECORATE_MODEL);\\n  }\\n\\n  class WithMeta extends BaseClass implements IMetaMixin {\\n    @computed public get meta() {\\n      const refDefs = getModelMetaKey(this, 'refs');\\n      const refs = {};\\n      Object.keys(refDefs).forEach((key) => {\\n        refs[key] = getRefId(this, key);\\n      });\\n\\n      return Object.freeze({\\n        collection: getModelCollection(this),\\n        id: getModelId(this),\\n        original: getModelMetaKey(this, 'originalId') && getOriginalModel(this) || undefined,\\n        refs,\\n        snapshot: modelToJSON(this),\\n        type: getModelType(this),\\n      });\\n    }\\n  }\\n\\n  return WithMeta as IModelConstructor<IMetaMixin<T> & T>;\\n}\\n\"]}","code":"import * as tslib_1 from \"tslib\";\r\nimport { computed } from 'mobx';\r\nimport { DECORATE_MODEL } from '../errors';\r\nimport { error } from '../helpers/format';\r\nimport { isModel } from '../helpers/mixin';\r\nimport { getRefId } from '../helpers/model/fields';\r\nimport { getModelCollection, getModelId, getModelMetaKey, getModelType, getOriginalModel, modelToJSON, } from '../helpers/model/utils';\r\n/**\r\n * Extends the model with the exposed meta data\r\n *\r\n * @export\r\n * @template T\r\n * @param {IModelConstructor<T>} Base Model to extend\r\n * @returns Extended model\r\n */\r\nexport function withMeta(Base) {\r\n    var BaseClass = Base;\r\n    if (!isModel(BaseClass)) {\r\n        throw error(DECORATE_MODEL);\r\n    }\r\n    var WithMeta = /** @class */ (function (_super) {\r\n        tslib_1.__extends(WithMeta, _super);\r\n        function WithMeta() {\r\n            return _super !== null && _super.apply(this, arguments) || this;\r\n        }\r\n        Object.defineProperty(WithMeta.prototype, \"meta\", {\r\n            get: function () {\r\n                var _this = this;\r\n                var refDefs = getModelMetaKey(this, 'refs');\r\n                var refs = {};\r\n                Object.keys(refDefs).forEach(function (key) {\r\n                    refs[key] = getRefId(_this, key);\r\n                });\r\n                return Object.freeze({\r\n                    collection: getModelCollection(this),\r\n                    id: getModelId(this),\r\n                    original: getModelMetaKey(this, 'originalId') && getOriginalModel(this) || undefined,\r\n                    refs: refs,\r\n                    snapshot: modelToJSON(this),\r\n                    type: getModelType(this),\r\n                });\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        tslib_1.__decorate([\r\n            computed\r\n        ], WithMeta.prototype, \"meta\", null);\r\n        return WithMeta;\r\n    }(BaseClass));\r\n    return WithMeta;\r\n}\r\n//# sourceMappingURL=withMeta.js.map","dts":{"name":"/Users/darko/Projects/mobx/datx/packages/datx/mixins/withMeta.d.ts","text":"import { IMetaMixin } from '../interfaces/IMetaMixin';\r\nimport { IModelConstructor } from '../interfaces/IModelConstructor';\r\nimport { PureModel } from '../PureModel';\r\n/**\r\n * Extends the model with the exposed meta data\r\n *\r\n * @export\r\n * @template T\r\n * @param {IModelConstructor<T>} Base Model to extend\r\n * @returns Extended model\r\n */\r\nexport declare function withMeta<T extends PureModel>(Base: IModelConstructor<T>): IModelConstructor<IMetaMixin<T> & T>;\r\n"}}

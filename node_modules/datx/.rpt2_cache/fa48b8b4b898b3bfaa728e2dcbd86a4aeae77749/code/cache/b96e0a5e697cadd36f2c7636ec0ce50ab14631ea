{"code":"import { META_FIELD, warn } from 'datx-utils';\r\nimport { toJS } from 'mobx';\r\nimport { NO_REFS, NOT_A_CLONE, REF_NEEDS_COLLECTION } from '../../errors';\r\nimport { PureModel } from '../../PureModel';\r\nimport { storage } from '../../services/storage';\r\nimport { error } from '../format';\r\nimport { initModelField } from '../model/init';\r\n/**\r\n * Get the model type\r\n *\r\n * @export\r\n * @param {(IType|typeof PureModel|PureModel)} model Model to be checked\r\n * @returns {IType} Model type\r\n */\r\nexport function getModelType(model) {\r\n    if (typeof model === 'function') {\r\n        return model.type;\r\n    }\r\n    else if (typeof model === 'object') {\r\n        return getModelMetaKey(model, 'type') || model.constructor.type;\r\n    }\r\n    return model;\r\n}\r\n/**\r\n * Get the model identifier\r\n *\r\n * @export\r\n * @param {(PureModel|IIdentifier)} model Model to be checked\r\n * @returns {IIdentifier} Model identifier\r\n */\r\nexport function getModelId(model) {\r\n    if (model instanceof PureModel) {\r\n        return getModelMetaKey(model, 'id');\r\n    }\r\n    return model;\r\n}\r\n/**\r\n * Get a collection the given model belongs to\r\n *\r\n * @export\r\n * @param {PureModel} model Model to be checked\r\n * @returns {PureCollection} A collection the given model belongs to\r\n */\r\nexport function getModelCollection(model) {\r\n    return getModelMetaKey(model, 'collection');\r\n}\r\n/**\r\n * Clone the given model\r\n *\r\n * @export\r\n * @template T\r\n * @param {T} model Model to be clones\r\n * @returns {T} Cloned model object\r\n */\r\nexport function cloneModel(model) {\r\n    var TypeModel = model.constructor;\r\n    var rawData = modelToJSON(model);\r\n    var meta = rawData[META_FIELD] || {};\r\n    meta.originalId = meta.id;\r\n    delete meta.id;\r\n    var clone = new TypeModel(rawData);\r\n    var collection = getModelCollection(model);\r\n    if (collection) {\r\n        collection.add(clone);\r\n    }\r\n    else {\r\n        warn(\"The model is not in the collection. Referencing the original model won't be possible\");\r\n    }\r\n    return clone;\r\n}\r\n/**\r\n * Get the original model for the cloned model\r\n *\r\n * @export\r\n * @param {PureModel} model Cloned model\r\n * @returns {PureModel} Original model\r\n */\r\nexport function getOriginalModel(model) {\r\n    var collection = getModelCollection(model);\r\n    var originalId = getModelMetaKey(model, 'originalId');\r\n    if (originalId) {\r\n        if (!collection) {\r\n            throw error(REF_NEEDS_COLLECTION);\r\n        }\r\n        return collection.find(model, originalId);\r\n    }\r\n    throw error(NOT_A_CLONE);\r\n}\r\n/**\r\n * Bulk update the model data\r\n *\r\n * @export\r\n * @template T\r\n * @param {T} model Model to be updated\r\n * @param {IDictionary} data Data that should be assigned to the model\r\n * @returns {T}\r\n */\r\nexport function updateModel(model, data) {\r\n    var modelId = storage.getModelClassMetaKey(model.constructor, 'id') || 'id';\r\n    var modelType = storage.getModelClassMetaKey(model.constructor, 'type') || 'type';\r\n    var keys = Object.keys(data instanceof PureModel ? modelToJSON(data) : data);\r\n    keys.forEach(function (key) {\r\n        if (key !== META_FIELD && key !== modelId && key !== modelType) {\r\n            assignModel(model, key, data[key]);\r\n        }\r\n    });\r\n    return model;\r\n}\r\n/**\r\n * Assign a property to a model\r\n *\r\n * @export\r\n * @template T\r\n * @param {T} model A model to modify\r\n * @param {string} key Property name\r\n * @param {*} value Property value\r\n */\r\nexport function assignModel(model, key, value) {\r\n    var refs = getModelMetaKey(model, 'refs');\r\n    if (key in refs) {\r\n        assignModelRef(model, key, value);\r\n    }\r\n    else if (value instanceof PureModel) {\r\n        throw error(NO_REFS, { key: key });\r\n    }\r\n    else {\r\n        assignModelField(model, key, value);\r\n    }\r\n}\r\nfunction assignModelField(model, key, value) {\r\n    var fields = getModelMetaKey(model, 'fields');\r\n    if (fields.indexOf(key) !== -1) {\r\n        model[key] = value;\r\n    }\r\n    else {\r\n        initModelField(model, key, value);\r\n    }\r\n}\r\nfunction assignModelRef(model, key, value) {\r\n    var refs = getModelMetaKey(model, 'refs');\r\n    model[key] = value;\r\n}\r\nexport function getMetaKeyFromRaw(data, key, model) {\r\n    if (META_FIELD in data && typeof data[META_FIELD] === 'object' && data[META_FIELD] !== undefined) {\r\n        return (data[META_FIELD] || {})[key];\r\n    }\r\n    if (model) {\r\n        var modelId = storage.getModelClassMetaKey(model, key);\r\n        return modelId && data[modelId];\r\n    }\r\n    return data && data[key];\r\n}\r\n/**\r\n * Get a serializable value of the model\r\n *\r\n * @export\r\n * @param {PureModel} model Model to serialize\r\n * @returns {IRawModel} Pure JS value of the model\r\n */\r\nexport function modelToJSON(model) {\r\n    var data = toJS(storage.getModelData(model));\r\n    var rawMeta = Object.assign({}, storage.getModelMeta(model));\r\n    delete rawMeta.collection;\r\n    var meta = toJS(rawMeta);\r\n    delete meta.collection;\r\n    var raw = Object.assign(data, (_a = {}, _a[META_FIELD] = meta, _a));\r\n    var staticModel = model.constructor;\r\n    var modelId = storage.getModelClassMetaKey(staticModel, 'id');\r\n    var modelType = storage.getModelClassMetaKey(staticModel, 'type');\r\n    if (meta && modelId) {\r\n        raw[modelId] = meta.id;\r\n    }\r\n    if (meta && modelType) {\r\n        raw[modelType] = meta.type;\r\n    }\r\n    return raw;\r\n    var _a;\r\n}\r\nexport function getModelMetaKey(model, key) {\r\n    return storage.getModelMetaKey(model, key);\r\n}\r\nexport function setModelMetaKey(model, key, value) {\r\n    storage.setModelMetaKey(model, key, value);\r\n    return;\r\n}\r\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvaGVscGVycy9tb2RlbC91dGlscy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQXlCLFVBQVUsRUFBRSxJQUFJLEVBQUMsTUFBTSxZQUFZLENBQUM7QUFDcEUsT0FBTyxFQUFDLElBQUksRUFBQyxNQUFNLE1BQU0sQ0FBQztBQUUxQixPQUFPLEVBQUMsT0FBTyxFQUFFLFdBQVcsRUFBRSxvQkFBb0IsRUFBQyxNQUFNLGNBQWMsQ0FBQztBQU14RSxPQUFPLEVBQUMsU0FBUyxFQUFDLE1BQU0saUJBQWlCLENBQUM7QUFDMUMsT0FBTyxFQUFDLE9BQU8sRUFBQyxNQUFNLHdCQUF3QixDQUFDO0FBQy9DLE9BQU8sRUFBQyxLQUFLLEVBQUMsTUFBTSxXQUFXLENBQUM7QUFDaEMsT0FBTyxFQUFDLGNBQWMsRUFBQyxNQUFNLGVBQWUsQ0FBQztBQUU3Qzs7Ozs7O0dBTUc7QUFDSCxNQUFNLHVCQUF1QixLQUF1QztJQUNsRSxJQUFJLE9BQU8sS0FBSyxLQUFLLFVBQVUsRUFBRTtRQUMvQixPQUFPLEtBQUssQ0FBQyxJQUFJLENBQUM7S0FDbkI7U0FBTSxJQUFJLE9BQU8sS0FBSyxLQUFLLFFBQVEsRUFBRTtRQUNwQyxPQUFPLGVBQWUsQ0FBQyxLQUFLLEVBQUUsTUFBTSxDQUFDLElBQUssS0FBSyxDQUFDLFdBQWdDLENBQUMsSUFBSSxDQUFDO0tBQ3ZGO0lBRUQsT0FBTyxLQUFLLENBQUM7QUFDZixDQUFDO0FBRUQ7Ozs7OztHQU1HO0FBQ0gsTUFBTSxxQkFBcUIsS0FBNEI7SUFDckQsSUFBSSxLQUFLLFlBQVksU0FBUyxFQUFFO1FBQzlCLE9BQU8sZUFBZSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQztLQUNyQztJQUVELE9BQU8sS0FBSyxDQUFDO0FBQ2YsQ0FBQztBQUVEOzs7Ozs7R0FNRztBQUNILE1BQU0sNkJBQTZCLEtBQWdCO0lBQ2pELE9BQU8s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QUMsZUFBZSxDQUFDLEtBQUssRUFBRSxHQUFHLEVBQUUsS0FBSyxDQUFDLENBQUM7SUFFM0MsT0FBTztBQUNULENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0lEaWN0aW9uYXJ5LCBJUmF3TW9kZWwsIE1FVEFfRklFTEQsIHdhcm59IGZyb20gJ2RhdHgtdXRpbHMnO1xuaW1wb3J0IHt0b0pTfSBmcm9tICdtb2J4JztcblxuaW1wb3J0IHtOT19SRUZTLCBOT1RfQV9DTE9ORSwgUkVGX05FRURTX0NPTExFQ1RJT059IGZyb20gJy4uLy4uL2Vycm9ycyc7XG5pbXBvcnQge0lJZGVudGlmaWVyfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL0lJZGVudGlmaWVyJztcbmltcG9ydCB7SVJlZmVyZW5jZU9wdGlvbnN9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvSVJlZmVyZW5jZU9wdGlvbnMnO1xuaW1wb3J0IHtJVHlwZX0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9JVHlwZSc7XG5pbXBvcnQge1RSZWZWYWx1ZX0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9UUmVmVmFsdWUnO1xuaW1wb3J0IHtQdXJlQ29sbGVjdGlvbn0gZnJvbSAnLi4vLi4vUHVyZUNvbGxlY3Rpb24nO1xuaW1wb3J0IHtQdXJlTW9kZWx9IGZyb20gJy4uLy4uL1B1cmVNb2RlbCc7XG5pbXBvcnQge3N0b3JhZ2V9IGZyb20gJy4uLy4uL3NlcnZpY2VzL3N0b3JhZ2UnO1xuaW1wb3J0IHtlcnJvcn0gZnJvbSAnLi4vZm9ybWF0JztcbmltcG9ydCB7aW5pdE1vZGVsRmllbGR9IGZyb20gJy4uL21vZGVsL2luaXQnO1xuXG4vKipcbiAqIEdldCB0aGUgbW9kZWwgdHlwZVxuICpcbiAqIEBleHBvcnRcbiAqIEBwYXJhbSB7KElUeXBlfHR5cGVvZiBQdXJlTW9kZWx8UHVyZU1vZGVsKX0gbW9kZWwgTW9kZWwgdG8gYmUgY2hlY2tlZFxuICogQHJldHVybnMge0lUeXBlfSBNb2RlbCB0eXBlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRNb2RlbFR5cGUobW9kZWw6IElUeXBlfHR5cGVvZiBQdXJlTW9kZWx8UHVyZU1vZGVsKTogSVR5cGUge1xuICBpZiAodHlwZW9mIG1vZGVsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG1vZGVsLnR5cGU7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG1vZGVsID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBnZXRNb2RlbE1ldGFLZXkobW9kZWwsICd0eXBlJykgfHwgKG1vZGVsLmNvbnN0cnVjdG9yIGFzIHR5cGVvZiBQdXJlTW9kZWwpLnR5cGU7XG4gIH1cblxuICByZXR1cm4gbW9kZWw7XG59XG5cbi8qKlxuICogR2V0IHRoZSBtb2RlbCBpZGVudGlmaWVyXG4gKlxuICogQGV4cG9ydFxuICogQHBhcmFtIHsoUHVyZU1vZGVsfElJZGVudGlmaWVyKX0gbW9kZWwgTW9kZWwgdG8gYmUgY2hlY2tlZFxuICogQHJldHVybnMge0lJZGVudGlmaWVyfSBNb2RlbCBpZGVudGlmaWVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRNb2RlbElkKG1vZGVsOiBQdXJlTW9kZWx8SUlkZW50aWZpZXIpOiBJSWRlbnRpZmllciB7XG4gIGlmIChtb2RlbCBpbnN0YW5jZW9mIFB1cmVNb2RlbCkge1xuICAgIHJldHVybiBnZXRNb2RlbE1ldGFLZXkobW9kZWwsICdpZCcpO1xuICB9XG5cbiAgcmV0dXJuIG1vZGVsO1xufVxuXG4vKipcbiAqIEdldCBhIGNvbGxlY3Rpb24gdGhlIGdpdmVuIG1vZGVsIGJlbG9uZ3MgdG9cbiAqXG4gKiBAZXhwb3J0XG4gKiBAcGFyYW0ge1B1cmVNb2RlbH0gbW9kZWwgTW9kZWwgdG8gYmUgY2hlY2tlZFxuICogQHJldHVybnMge1B1cmVDb2xsZWN0aW9ufSBBIGNvbGxlY3Rpb24gdGhlIGdpdmVuIG1vZGVsIGJlbG9uZ3MgdG9cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE1vZGVsQ29sbGVjdGlvbihtb2RlbDogUHVyZU1vZGVsKTogUHVyZUNvbGxlY3Rpb258dW5kZWZpbmVkIHtcbiAgcmV0dXJuIGdldE1vZGVsTWV0YUtleShtb2RlbCwgJ2NvbGxlY3Rpb24nKTtcbn1cblxuLyoqXG4gKiBDbG9uZSB0aGUgZ2l2ZW4gbW9kZWxcbiAqXG4gKiBAZXhwb3J0XG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtUfSBtb2RlbCBNb2RlbCB0byBiZSBjbG9uZXNcbiAqIEByZXR1cm5zIHtUfSBDbG9uZWQgbW9kZWwgb2JqZWN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZU1vZGVsPFQgZXh0ZW5kcyBQdXJlTW9kZWw+KG1vZGVsOiBUKTogVCB7XG4gIGNvbnN0IFR5cGVNb2RlbCA9IG1vZGVsLmNvbnN0cnVjdG9yIGFzIHR5cGVvZiBQdXJlTW9kZWw7XG4gIGNvbnN0IHJhd0RhdGEgPSBtb2RlbFRvSlNPTihtb2RlbCk7XG4gIGNvbnN0IG1ldGEgPSByYXdEYXRhW01FVEFfRklFTERdIHx8IHt9O1xuICBtZXRhLm9yaWdpbmFsSWQgPSBtZXRhLmlkO1xuICBkZWxldGUgbWV0YS5pZDtcblxuICBjb25zdCBjbG9uZSA9IG5ldyBUeXBlTW9kZWwocmF3RGF0YSkgYXMgVDtcblxuICBjb25zdCBjb2xsZWN0aW9uID0gZ2V0TW9kZWxDb2xsZWN0aW9uKG1vZGVsKTtcbiAgaWYgKGNvbGxlY3Rpb24pIHtcbiAgICBjb2xsZWN0aW9uLmFkZChjbG9uZSk7XG4gIH0gZWxzZSB7XG4gICAgd2FybihgVGhlIG1vZGVsIGlzIG5vdCBpbiB0aGUgY29sbGVjdGlvbi4gUmVmZXJlbmNpbmcgdGhlIG9yaWdpbmFsIG1vZGVsIHdvbid0IGJlIHBvc3NpYmxlYCk7XG4gIH1cblxuICByZXR1cm4gY2xvbmU7XG59XG5cbi8qKlxuICogR2V0IHRoZSBvcmlnaW5hbCBtb2RlbCBmb3IgdGhlIGNsb25lZCBtb2RlbFxuICpcbiAqIEBleHBvcnRcbiAqIEBwYXJhbSB7UHVyZU1vZGVsfSBtb2RlbCBDbG9uZWQgbW9kZWxcbiAqIEByZXR1cm5zIHtQdXJlTW9kZWx9IE9yaWdpbmFsIG1vZGVsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRPcmlnaW5hbE1vZGVsKG1vZGVsOiBQdXJlTW9kZWwpOiBQdXJlTW9kZWwge1xuICBjb25zdCBjb2xsZWN0aW9uID0gZ2V0TW9kZWxDb2xsZWN0aW9uKG1vZGVsKTtcbiAgY29uc3Qgb3JpZ2luYWxJZCA9IGdldE1vZGVsTWV0YUtleShtb2RlbCwgJ29yaWdpbmFsSWQnKTtcbiAgaWYgKG9yaWdpbmFsSWQpIHtcbiAgICBpZiAoIWNvbGxlY3Rpb24pIHtcbiAgICAgIHRocm93IGVycm9yKFJFRl9ORUVEU19DT0xMRUNUSU9OKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29sbGVjdGlvbi5maW5kKG1vZGVsLCBvcmlnaW5hbElkKSBhcyBQdXJlTW9kZWw7XG4gIH1cbiAgdGhyb3cgZXJyb3IoTk9UX0FfQ0xPTkUpO1xufVxuXG4vKipcbiAqIEJ1bGsgdXBkYXRlIHRoZSBtb2RlbCBkYXRhXG4gKlxuICogQGV4cG9ydFxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7VH0gbW9kZWwgTW9kZWwgdG8gYmUgdXBkYXRlZFxuICogQHBhcmFtIHtJRGljdGlvbmFyeX0gZGF0YSBEYXRhIHRoYXQgc2hvdWxkIGJlIGFzc2lnbmVkIHRvIHRoZSBtb2RlbFxuICogQHJldHVybnMge1R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVNb2RlbDxUIGV4dGVuZHMgUHVyZU1vZGVsPihtb2RlbDogVCwgZGF0YTogSURpY3Rpb25hcnkpOiBUIHtcbiAgY29uc3QgbW9kZWxJZCA9IHN0b3JhZ2UuZ2V0TW9kZWxDbGFzc01ldGFLZXkobW9kZWwuY29uc3RydWN0b3IgYXMgdHlwZW9mIFB1cmVNb2RlbCwgJ2lkJykgfHwgJ2lkJztcbiAgY29uc3QgbW9kZWxUeXBlID0gc3RvcmFnZS5nZXRNb2RlbENsYXNzTWV0YUtleShtb2RlbC5jb25zdHJ1Y3RvciBhcyB0eXBlb2YgUHVyZU1vZGVsLCAndHlwZScpIHx8ICd0eXBlJztcblxuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSBpbnN0YW5jZW9mIFB1cmVNb2RlbCA/IG1vZGVsVG9KU09OKGRhdGEpIDogZGF0YSk7XG4gIGtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgaWYgKGtleSAhPT0gTUVUQV9GSUVMRCAmJiBrZXkgIT09IG1vZGVsSWQgJiYga2V5ICE9PSBtb2RlbFR5cGUpIHtcbiAgICAgIGFzc2lnbk1vZGVsKG1vZGVsLCBrZXksIGRhdGFba2V5XSk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gbW9kZWw7XG59XG5cbi8qKlxuICogQXNzaWduIGEgcHJvcGVydHkgdG8gYSBtb2RlbFxuICpcbiAqIEBleHBvcnRcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1R9IG1vZGVsIEEgbW9kZWwgdG8gbW9kaWZ5XG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFByb3BlcnR5IG5hbWVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgUHJvcGVydHkgdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbk1vZGVsPFQgZXh0ZW5kcyBQdXJlTW9kZWw+KG1vZGVsOiBULCBrZXk6IHN0cmluZywgdmFsdWU6IGFueSk6IHZvaWQge1xuICBjb25zdCByZWZzID0gZ2V0TW9kZWxNZXRhS2V5KG1vZGVsLCAncmVmcycpIGFzIElEaWN0aW9uYXJ5PElSZWZlcmVuY2VPcHRpb25zPjtcbiAgaWYgKGtleSBpbiByZWZzKSB7XG4gICAgYXNzaWduTW9kZWxSZWYobW9kZWwsIGtleSwgdmFsdWUpO1xuICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgUHVyZU1vZGVsKSB7XG4gICAgdGhyb3cgZXJyb3IoTk9fUkVGUywge2tleX0pO1xuICB9IGVsc2Uge1xuICAgIGFzc2lnbk1vZGVsRmllbGQobW9kZWwsIGtleSwgdmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2lnbk1vZGVsRmllbGQ8VCBleHRlbmRzIFB1cmVNb2RlbD4obW9kZWw6IFQsIGtleTogc3RyaW5nLCB2YWx1ZTogYW55KTogdm9pZCB7XG4gIGNvbnN0IGZpZWxkcyA9IGdldE1vZGVsTWV0YUtleShtb2RlbCwgJ2ZpZWxkcycpIGFzIEFycmF5PHN0cmluZz47XG4gIGlmIChmaWVsZHMuaW5kZXhPZihrZXkpICE9PSAtMSkge1xuICAgIG1vZGVsW2tleV0gPSB2YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICBpbml0TW9kZWxGaWVsZChtb2RlbCwga2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzaWduTW9kZWxSZWY8VCBleHRlbmRzIFB1cmVNb2RlbD4obW9kZWw6IFQsIGtleTogc3RyaW5nLCB2YWx1ZTogVFJlZlZhbHVlKTogdm9pZCB7XG4gIGNvbnN0IHJlZnMgPSBnZXRNb2RlbE1ldGFLZXkobW9kZWwsICdyZWZzJyk7XG4gIG1vZGVsW2tleV0gPSB2YWx1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldE1ldGFLZXlGcm9tUmF3KGRhdGE6IElSYXdNb2RlbCwga2V5OiBzdHJpbmcsIG1vZGVsPzogdHlwZW9mIFB1cmVNb2RlbCk6IGFueSB7XG4gIGlmIChNRVRBX0ZJRUxEIGluIGRhdGEgJiYgdHlwZW9mIGRhdGFbTUVUQV9GSUVMRF0gPT09ICdvYmplY3QnICYmIGRhdGFbTUVUQV9GSUVMRF0gIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiAoZGF0YVtNRVRBX0ZJRUxEXSB8fCB7fSlba2V5XTtcbiAgfVxuICBpZiAobW9kZWwpIHtcbiAgICBjb25zdCBtb2RlbElkID0gc3RvcmFnZS5nZXRNb2RlbENsYXNzTWV0YUtleShtb2RlbCwga2V5KTtcblxuICAgIHJldHVybiBtb2RlbElkICYmIGRhdGFbbW9kZWxJZF07XG4gIH1cblxuICByZXR1cm4gZGF0YSAmJiBkYXRhW2tleV07XG59XG5cbi8qKlxuICogR2V0IGEgc2VyaWFsaXphYmxlIHZhbHVlIG9mIHRoZSBtb2RlbFxuICpcbiAqIEBleHBvcnRcbiAqIEBwYXJhbSB7UHVyZU1vZGVsfSBtb2RlbCBNb2RlbCB0byBzZXJpYWxpemVcbiAqIEByZXR1cm5zIHtJUmF3TW9kZWx9IFB1cmUgSlMgdmFsdWUgb2YgdGhlIG1vZGVsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtb2RlbFRvSlNPTihtb2RlbDogUHVyZU1vZGVsKTogSVJhd01vZGVsIHtcbiAgY29uc3QgZGF0YSA9IHRvSlMoc3RvcmFnZS5nZXRNb2RlbERhdGEobW9kZWwpKTtcblxuICBjb25zdCByYXdNZXRhID0gT2JqZWN0LmFzc2lnbih7fSwgc3RvcmFnZS5nZXRNb2RlbE1ldGEobW9kZWwpKTtcbiAgZGVsZXRlIHJhd01ldGEuY29sbGVjdGlvbjtcbiAgY29uc3QgbWV0YSA9IHRvSlMocmF3TWV0YSk7XG5cbiAgZGVsZXRlIG1ldGEuY29sbGVjdGlvbjtcblxuICBjb25zdCByYXcgPSBPYmplY3QuYXNzaWduKGRhdGEsIHtbTUVUQV9GSUVMRF06IG1ldGF9KTtcblxuICBjb25zdCBzdGF0aWNNb2RlbCA9IG1vZGVsLmNvbnN0cnVjdG9yIGFzIHR5cGVvZiBQdXJlTW9kZWw7XG4gIGNvbnN0IG1vZGVsSWQgPSBzdG9yYWdlLmdldE1vZGVsQ2xhc3NNZXRhS2V5KHN0YXRpY01vZGVsLCAnaWQnKTtcbiAgY29uc3QgbW9kZWxUeXBlID0gc3RvcmFnZS5nZXRNb2RlbENsYXNzTWV0YUtleShzdGF0aWNNb2RlbCwgJ3R5cGUnKTtcbiAgaWYgKG1ldGEgJiYgbW9kZWxJZCkge1xuICAgIHJhd1ttb2RlbElkXSA9IG1ldGEuaWQ7XG4gIH1cbiAgaWYgKG1ldGEgJiYgbW9kZWxUeXBlKSB7XG4gICAgcmF3W21vZGVsVHlwZV0gPSBtZXRhLnR5cGU7XG4gIH1cblxuICByZXR1cm4gcmF3O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TW9kZWxNZXRhS2V5KG1vZGVsOiBQdXJlTW9kZWwsIGtleTogc3RyaW5nKSB7XG4gIHJldHVybiBzdG9yYWdlLmdldE1vZGVsTWV0YUtleShtb2RlbCwga2V5KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldE1vZGVsTWV0YUtleShtb2RlbDogUHVyZU1vZGVsLCBrZXk6IHN0cmluZywgdmFsdWU6IGFueSkge1xuICBzdG9yYWdlLnNldE1vZGVsTWV0YUtleShtb2RlbCwga2V5LCB2YWx1ZSk7XG5cbiAgcmV0dXJuO1xufVxuIl19","dts":{"name":"/Users/darko/Projects/mobx/datx/packages/datx/helpers/model/utils.d.ts","text":"import { IDictionary, IRawModel } from 'datx-utils';\r\nimport { IIdentifier } from '../../interfaces/IIdentifier';\r\nimport { IType } from '../../interfaces/IType';\r\nimport { PureCollection } from '../../PureCollection';\r\nimport { PureModel } from '../../PureModel';\r\n/**\r\n * Get the model type\r\n *\r\n * @export\r\n * @param {(IType|typeof PureModel|PureModel)} model Model to be checked\r\n * @returns {IType} Model type\r\n */\r\nexport declare function getModelType(model: IType | typeof PureModel | PureModel): IType;\r\n/**\r\n * Get the model identifier\r\n *\r\n * @export\r\n * @param {(PureModel|IIdentifier)} model Model to be checked\r\n * @returns {IIdentifier} Model identifier\r\n */\r\nexport declare function getModelId(model: PureModel | IIdentifier): IIdentifier;\r\n/**\r\n * Get a collection the given model belongs to\r\n *\r\n * @export\r\n * @param {PureModel} model Model to be checked\r\n * @returns {PureCollection} A collection the given model belongs to\r\n */\r\nexport declare function getModelCollection(model: PureModel): PureCollection | undefined;\r\n/**\r\n * Clone the given model\r\n *\r\n * @export\r\n * @template T\r\n * @param {T} model Model to be clones\r\n * @returns {T} Cloned model object\r\n */\r\nexport declare function cloneModel<T extends PureModel>(model: T): T;\r\n/**\r\n * Get the original model for the cloned model\r\n *\r\n * @export\r\n * @param {PureModel} model Cloned model\r\n * @returns {PureModel} Original model\r\n */\r\nexport declare function getOriginalModel(model: PureModel): PureModel;\r\n/**\r\n * Bulk update the model data\r\n *\r\n * @export\r\n * @template T\r\n * @param {T} model Model to be updated\r\n * @param {IDictionary} data Data that should be assigned to the model\r\n * @returns {T}\r\n */\r\nexport declare function updateModel<T extends PureModel>(model: T, data: IDictionary): T;\r\n/**\r\n * Assign a property to a model\r\n *\r\n * @export\r\n * @template T\r\n * @param {T} model A model to modify\r\n * @param {string} key Property name\r\n * @param {*} value Property value\r\n */\r\nexport declare function assignModel<T extends PureModel>(model: T, key: string, value: any): void;\r\nexport declare function getMetaKeyFromRaw(data: IRawModel, key: string, model?: typeof PureModel): any;\r\n/**\r\n * Get a serializable value of the model\r\n *\r\n * @export\r\n * @param {PureModel} model Model to serialize\r\n * @returns {IRawModel} Pure JS value of the model\r\n */\r\nexport declare function modelToJSON(model: PureModel): IRawModel;\r\nexport declare function getModelMetaKey(model: PureModel, key: string): any;\r\nexport declare function setModelMetaKey(model: PureModel, key: string, value: any): void;\r\n"}}

{"code":"import { mapItems, warn } from 'datx-utils';\r\nimport { intercept, isObservableArray, observable } from 'mobx';\r\nimport { FieldType } from '../../enums/FieldType';\r\nimport { ReferenceType } from '../../enums/ReferenceType';\r\nimport { BACK_REF_READ_ONLY, ID_READONLY, REF_ARRAY, REF_NEEDS_COLLECTION, REF_SINGLE, TYPE_READONLY, WRONG_REF_TYPE, } from '../../errors';\r\nimport { PureModel } from '../../PureModel';\r\nimport { storage } from '../../services/storage';\r\nimport { error } from '../format';\r\nimport { getModelCollection, getModelId, getModelMetaKey, getModelType, setModelMetaKey } from './utils';\r\nfunction modelAddReference(model, key, newReference) {\r\n    var refOptions = storage.getModelReferenceOptions(model, key);\r\n    var newRefId = getModelId(newReference);\r\n    var data = storage.getModelDataKey(model, key);\r\n    if (refOptions.type === ReferenceType.TO_ONE) {\r\n        storage.setModelDataKey(model, key, newRefId);\r\n    }\r\n    else if (refOptions.type === ReferenceType.TO_MANY || isObservableArray(data)) {\r\n        data.push(newRefId);\r\n    }\r\n    else {\r\n        storage.setModelDataKey(model, key, newReference);\r\n    }\r\n}\r\nfunction modelRemoveReference(model, key, oldReference) {\r\n    var refOptions = storage.getModelReferenceOptions(model, key);\r\n    var oldRefId = getModelId(oldReference);\r\n    var data = storage.getModelDataKey(model, key);\r\n    if (refOptions.type === ReferenceType.TO_ONE) {\r\n        storage.setModelDataKey(model, key, null);\r\n    }\r\n    else if (refOptions.type === ReferenceType.TO_MANY || isObservableArray(data)) {\r\n        data.remove(oldRefId);\r\n    }\r\n    else {\r\n        storage.setModelDataKey(model, key, null);\r\n    }\r\n}\r\nfunction ensureModel(refOptions, collection) {\r\n    return function (data) {\r\n        var model = data;\r\n        if (!(data instanceof PureModel) && typeof data === 'object') {\r\n            if (!collection) {\r\n                throw new Error(REF_NEEDS_COLLECTION);\r\n            }\r\n            model = collection.add(data, refOptions.model);\r\n        }\r\n        return getModelId(model);\r\n    };\r\n}\r\nfunction partialRefUpdate(model, key, change) {\r\n    var refOptions = storage.getModelReferenceOptions(model, key);\r\n    var data = storage.getModelDataKey(model, key);\r\n    var collection = getModelCollection(model);\r\n    if (change.type === 'splice') {\r\n        var added = change.added.map(ensureModel(refOptions, collection));\r\n        data.splice.apply(data, [change.index, change.removedCount].concat(added));\r\n        return null;\r\n    }\r\n    data[change.index] = ensureModel(refOptions, collection)(change.newValue);\r\n    return null;\r\n}\r\nfunction backRefSplice(model, key, change, refOptions) {\r\n    var property = refOptions.property;\r\n    change.added.forEach(function (item) {\r\n        modelAddReference(item, property, model);\r\n    });\r\n    var removed = model[key].slice(change.index, change.index + change.removedCount);\r\n    removed.forEach(function (item) {\r\n        modelRemoveReference(item, property, model);\r\n    });\r\n    return null;\r\n}\r\nfunction backRefChange(model, key, change, refOptions) {\r\n    var property = refOptions.property;\r\n    var oldValue = model[key].length > change.index ? model[key][change.index] : null;\r\n    if (change.newValue) {\r\n        modelAddReference(change.newValue, property, model);\r\n    }\r\n    if (oldValue) {\r\n        modelRemoveReference(oldValue, property, model);\r\n    }\r\n    warn(\"This shouldn't have happened. Please open an issue: https://github.com/infinum/datx/issues/new\");\r\n    return null;\r\n}\r\nfunction partialBackRefUpdate(model, key, change) {\r\n    var refOptions = storage.getModelReferenceOptions(model, key);\r\n    if (change.type === 'splice') {\r\n        return backRefSplice(model, key, change, refOptions);\r\n    }\r\n    return backRefChange(model, key, change, refOptions);\r\n}\r\nexport function getField(model, key) {\r\n    return storage.getModelDataKey(model, key);\r\n}\r\nexport function updateField(model, key, value, type) {\r\n    if (type === FieldType.TYPE) {\r\n        throw error(TYPE_READONLY);\r\n    }\r\n    else if (type === FieldType.ID) {\r\n        throw error(ID_READONLY);\r\n    }\r\n    var refs = getModelMetaKey(model, 'refs');\r\n    if (key in refs) {\r\n        updateRef(model, key, value);\r\n    }\r\n    else {\r\n        storage.setModelDataKey(model, key, value);\r\n    }\r\n}\r\nfunction hasBackRef(item, property, target) {\r\n    if (item[property] === null || item[property] === undefined) {\r\n        return false;\r\n    }\r\n    else if (item[property] instanceof PureModel) {\r\n        return item[property] === target;\r\n    }\r\n    else {\r\n        return item[property].indexOf(target) !== -1;\r\n    }\r\n}\r\nfunction getBackRef(model, key, refOptions) {\r\n    var type = getModelType(refOptions.model);\r\n    var collection = getModelCollection(model);\r\n    if (!collection) {\r\n        return null;\r\n    }\r\n    var backModels = collection\r\n        .findAll(type)\r\n        .filter(function (item) { return hasBackRef(item, refOptions.property, model); });\r\n    var backData = observable.array(backModels, { deep: false });\r\n    intercept(backData, function (change) { return partialBackRefUpdate(model, key, change); });\r\n    return backData;\r\n}\r\nfunction getNormalRef(model, key, refOptions) {\r\n    var value = storage.getModelDataKey(model, key);\r\n    var collection = getModelCollection(model);\r\n    if (!collection) {\r\n        return null;\r\n    }\r\n    var dataModels = mapItems(value, function (id) { return id ? collection.find(refOptions.model, id) : id; });\r\n    if (refOptions.type === ReferenceType.TO_MANY && !(dataModels instanceof Array)) {\r\n        dataModels = [dataModels];\r\n    }\r\n    if (dataModels instanceof Array) {\r\n        var data = observable.array(dataModels, { deep: false });\r\n        intercept(data, function (change) { return partialRefUpdate(model, key, change); });\r\n        return data;\r\n    }\r\n    return dataModels;\r\n}\r\nexport function getRef(model, key) {\r\n    var refOptions = storage.getModelReferenceOptions(model, key);\r\n    return (typeof refOptions.property === 'string')\r\n        ? getBackRef(model, key, refOptions)\r\n        : getNormalRef(model, key, refOptions);\r\n}\r\nfunction validateRef(refOptions, isArray, key) {\r\n    if (refOptions.type === ReferenceType.TO_ONE && isArray) {\r\n        throw error(REF_SINGLE, { key: key });\r\n    }\r\n    else if (refOptions.type === ReferenceType.TO_MANY && !isArray) {\r\n        throw error(REF_ARRAY, { key: key });\r\n    }\r\n    else if (refOptions.property) {\r\n        throw error(BACK_REF_READ_ONLY);\r\n    }\r\n}\r\nexport function updateRef(model, key, value) {\r\n    var refOptions = storage.getModelReferenceOptions(model, key);\r\n    var check = refOptions.type === ReferenceType.TO_MANY ? value || [] : value;\r\n    var isArray = check instanceof Array || isObservableArray(check);\r\n    validateRef(refOptions, isArray, key);\r\n    var collection = getModelCollection(model);\r\n    var ids = mapItems(value, function (ref) {\r\n        if (ref && collection) {\r\n            if (ref instanceof PureModel) {\r\n                var refType = getModelType(ref);\r\n                if (refType !== getModelType(refOptions.model)) {\r\n                    throw new Error(WRONG_REF_TYPE);\r\n                }\r\n            }\r\n            var instance = collection.find(refOptions.model, ref);\r\n            if (!instance && typeof ref === 'object') {\r\n                instance = collection.add(ref, refOptions.model);\r\n            }\r\n            return getModelId(instance || ref);\r\n        }\r\n        else if (ref instanceof PureModel) {\r\n            throw error(REF_NEEDS_COLLECTION);\r\n        }\r\n        return ref;\r\n    });\r\n    if (refOptions.type === ReferenceType.TO_MANY) {\r\n        ids = ids || [];\r\n    }\r\n    storage.setModelDataKey(model, key, ids);\r\n}\r\nfunction getModelRefsByType(model, type) {\r\n    var refs = getModelMetaKey(model, 'refs');\r\n    return Object.keys(refs)\r\n        .filter(function (key) { return !refs[key].property; })\r\n        .filter(function (key) { return getModelType(refs[key].model) === type; });\r\n}\r\nfunction updateModelReferences(model, newId, oldId, type) {\r\n    var collection = getModelCollection(model);\r\n    if (collection) {\r\n        var allModels = collection.getAllModels().map(function (item) {\r\n            getModelRefsByType(item, type).forEach(function (ref) {\r\n                var data = storage.getModelDataKey(item, ref);\r\n                if (data instanceof Array || isObservableArray(data)) {\r\n                    var targetIndex = data.indexOf(oldId);\r\n                    if (targetIndex !== -1) {\r\n                        data[targetIndex] = newId;\r\n                    }\r\n                }\r\n                else if (data === oldId) {\r\n                    storage.setModelDataKey(item, ref, newId);\r\n                }\r\n            });\r\n        });\r\n    }\r\n}\r\n/**\r\n * Updates the model identifier and all the existing references to the model\r\n *\r\n * @export\r\n * @param {PureModel} model Model to be updated\r\n * @param {IIdentifier} newId New model identifier\r\n */\r\nexport function updateModelId(model, newId) {\r\n    var collection = getModelCollection(model);\r\n    var oldId = getModelId(model);\r\n    var type = getModelType(model);\r\n    setModelMetaKey(model, 'id', newId);\r\n    var staticModel = model.constructor;\r\n    var modelId = storage.getModelClassMetaKey(staticModel, 'id');\r\n    if (modelId) {\r\n        setRefId(model, modelId, newId);\r\n    }\r\n    if (collection) {\r\n        // @ts-ignore - I'm bad and I should feel bad...\r\n        collection.__changeModelId(oldId, newId, type);\r\n    }\r\n    updateModelReferences(model, newId, oldId, type);\r\n}\r\n/**\r\n * Get the id of the referenced model\r\n *\r\n * @export\r\n * @param {PureModel} model Source model\r\n * @param {string} key Referenced model property name\r\n * @returns {IIdentifier} Referenced model id\r\n */\r\nexport function getRefId(model, key) {\r\n    return storage.getModelDataKey(model, key);\r\n}\r\n/**\r\n * Set the id of the referenced model\r\n *\r\n * @export\r\n * @param {PureModel} model Source model\r\n * @param {string} key Referenced model property name\r\n * @param {IIdentifier} value The new value\r\n * @returns {void} Referenced model id\r\n */\r\nexport function setRefId(model, key, value) {\r\n    storage.setModelDataKey(model, key, value);\r\n}\r\n//# sourceMappingURL=fields.js.map","map":"{\"version\":3,\"file\":\"fields.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../src/helpers/model/fields.ts\"],\"names\":[],\"mappings\":\"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\",\"sourcesContent\":[\"import {mapItems, warn} from 'datx-utils';\\nimport {IArrayChange, IArraySplice, intercept, IObservableArray, isObservableArray, observable} from 'mobx';\\n\\nimport {FieldType} from '../../enums/FieldType';\\nimport {ReferenceType} from '../../enums/ReferenceType';\\nimport {\\n  BACK_REF_READ_ONLY,\\n  ID_READONLY,\\n  REF_ARRAY,\\n  REF_NEEDS_COLLECTION,\\n  REF_SINGLE,\\n  TYPE_READONLY,\\n  WRONG_REF_TYPE,\\n} from '../../errors';\\nimport {IIdentifier} from '../../interfaces/IIdentifier';\\nimport {IReferenceOptions} from '../../interfaces/IReferenceOptions';\\nimport {IType} from '../../interfaces/IType';\\nimport {TChange} from '../../interfaces/TChange';\\nimport {TRefValue} from '../../interfaces/TRefValue';\\nimport {PureCollection} from '../../PureCollection';\\nimport {PureModel} from '../../PureModel';\\nimport {storage} from '../../services/storage';\\nimport {error} from '../format';\\nimport {getModelCollection, getModelId, getModelMetaKey, getModelType, setModelMetaKey} from './utils';\\n\\nfunction modelAddReference(model: PureModel, key: string, newReference: PureModel) {\\n  const refOptions = storage.getModelReferenceOptions(model, key);\\n  const newRefId = getModelId(newReference);\\n  const data = storage.getModelDataKey(model, key);\\n  if (refOptions.type === ReferenceType.TO_ONE) {\\n    storage.setModelDataKey(model, key, newRefId);\\n  } else if (refOptions.type === ReferenceType.TO_MANY || isObservableArray(data)) {\\n    data.push(newRefId);\\n  } else {\\n    storage.setModelDataKey(model, key, newReference);\\n  }\\n}\\n\\nfunction modelRemoveReference(model: PureModel, key: string, oldReference: PureModel) {\\n  const refOptions = storage.getModelReferenceOptions(model, key);\\n  const oldRefId = getModelId(oldReference);\\n  const data = storage.getModelDataKey(model, key);\\n  if (refOptions.type === ReferenceType.TO_ONE) {\\n    storage.setModelDataKey(model, key, null);\\n  } else if (refOptions.type === ReferenceType.TO_MANY || isObservableArray(data)) {\\n    data.remove(oldRefId);\\n  } else {\\n    storage.setModelDataKey(model, key, null);\\n  }\\n}\\n\\nfunction ensureModel(refOptions: IReferenceOptions, collection?: PureCollection) {\\n  return (data) => {\\n    let model = data;\\n    if (!(data instanceof PureModel) && typeof data === 'object') {\\n      if (!collection) {\\n        throw new Error(REF_NEEDS_COLLECTION);\\n      }\\n      model = collection.add(data, refOptions.model);\\n    }\\n\\n    return getModelId(model);\\n  };\\n}\\n\\nfunction partialRefUpdate(model: PureModel, key: string, change: TChange) {\\n  const refOptions = storage.getModelReferenceOptions(model, key);\\n  const data = storage.getModelDataKey(model, key);\\n  const collection = getModelCollection(model);\\n\\n  if (change.type === 'splice') {\\n    const added = change.added.map(ensureModel(refOptions, collection));\\n    data.splice(change.index, change.removedCount, ...added);\\n\\n    return null;\\n  }\\n\\n  data[change.index] = ensureModel(refOptions, collection)(change.newValue);\\n\\n  return null;\\n}\\n\\nfunction backRefSplice(model: PureModel, key: string, change: IArraySplice<PureModel>, refOptions: IReferenceOptions) {\\n  const property = refOptions.property as string;\\n  change.added.forEach((item) => {\\n    modelAddReference(item, property, model);\\n  });\\n  const removed = model[key].slice(change.index, change.index + change.removedCount);\\n  removed.forEach((item) => {\\n    modelRemoveReference(item, property, model);\\n  });\\n\\n  return null;\\n}\\n\\nfunction backRefChange(model: PureModel, key: string, change: IArrayChange<PureModel>, refOptions: IReferenceOptions) {\\n  const property = refOptions.property as string;\\n  const oldValue = model[key].length > change.index ? model[key][change.index] : null;\\n  if (change.newValue) {\\n    modelAddReference(change.newValue, property, model);\\n  }\\n  if (oldValue) {\\n    modelRemoveReference(oldValue, property, model);\\n  }\\n\\n  warn(`This shouldn't have happened. Please open an issue: https://github.com/infinum/datx/issues/new`);\\n\\n  return null;\\n}\\n\\nfunction partialBackRefUpdate(model: PureModel, key: string, change: TChange) {\\n  const refOptions = storage.getModelReferenceOptions(model, key);\\n\\n  if (change.type === 'splice') {\\n    return backRefSplice(model, key, change, refOptions);\\n  }\\n\\n  return backRefChange(model, key, change, refOptions);\\n}\\n\\nexport function getField(model: PureModel, key: string) {\\n  return storage.getModelDataKey(model, key);\\n}\\n\\nexport function updateField(model: PureModel, key: string, value: any, type: FieldType) {\\n  if (type === FieldType.TYPE) {\\n    throw error(TYPE_READONLY);\\n  } else if (type === FieldType.ID) {\\n    throw error(ID_READONLY);\\n  }\\n\\n  const refs = getModelMetaKey(model, 'refs');\\n  if (key in refs) {\\n    updateRef(model, key, value);\\n  } else {\\n    storage.setModelDataKey(model, key, value);\\n  }\\n}\\n\\nfunction hasBackRef(item: PureModel, property: string, target: PureModel): boolean {\\n  if (item[property] === null || item[property] === undefined) {\\n    return false;\\n  } else if (item[property] instanceof PureModel) {\\n    return item[property] === target;\\n  } else {\\n    return item[property].indexOf(target) !== -1;\\n  }\\n}\\n\\nfunction getBackRef(model: PureModel, key: string, refOptions: IReferenceOptions): PureModel|Array<PureModel>|null {\\n  const type = getModelType(refOptions.model);\\n\\n  const collection = getModelCollection(model);\\n  if (!collection) {\\n    return null;\\n  }\\n\\n  const backModels = collection\\n    .findAll(type)\\n    .filter((item) => hasBackRef(item, refOptions.property as string, model));\\n\\n  const backData: IObservableArray<PureModel> = observable.array(backModels, {deep: false});\\n  intercept(backData, (change: TChange) => partialBackRefUpdate(model, key, change));\\n\\n  return backData;\\n}\\n\\nfunction getNormalRef(model: PureModel, key: string, refOptions: IReferenceOptions): PureModel|Array<PureModel>|null {\\n  const value = storage.getModelDataKey(model, key);\\n  const collection = getModelCollection(model);\\n  if (!collection) {\\n    return null;\\n  }\\n\\n  let dataModels = mapItems(value, (id) => id ? collection.find(refOptions.model, id) : id);\\n  if (refOptions.type === ReferenceType.TO_MANY && !(dataModels instanceof Array)) {\\n    dataModels = [dataModels];\\n  }\\n  if (dataModels instanceof Array) {\\n    const data: IObservableArray<PureModel> = observable.array(dataModels, {deep: false});\\n    intercept(data, (change: TChange) => partialRefUpdate(model, key, change));\\n\\n    return data;\\n  }\\n\\n  return dataModels;\\n}\\n\\nexport function getRef(model: PureModel, key: string): PureModel|Array<PureModel>|null {\\n  const refOptions = storage.getModelReferenceOptions(model, key);\\n\\n  return (typeof refOptions.property === 'string')\\n    ? getBackRef(model, key, refOptions)\\n    : getNormalRef(model, key, refOptions);\\n}\\n\\nfunction validateRef(refOptions: IReferenceOptions, isArray: boolean, key: string) {\\n  if (refOptions.type === ReferenceType.TO_ONE && isArray) {\\n    throw error(REF_SINGLE, {key});\\n  } else if (refOptions.type === ReferenceType.TO_MANY && !isArray) {\\n    throw error(REF_ARRAY, {key});\\n  } else if (refOptions.property) {\\n    throw error(BACK_REF_READ_ONLY);\\n  }\\n}\\n\\nexport function updateRef(model: PureModel, key: string, value: TRefValue) {\\n  const refOptions = storage.getModelReferenceOptions(model, key);\\n\\n  const check = refOptions.type === ReferenceType.TO_MANY ? value || [] : value;\\n  const isArray = check instanceof Array || isObservableArray(check);\\n  validateRef(refOptions, isArray, key);\\n\\n  const collection = getModelCollection(model);\\n\\n  let ids: IIdentifier|Array<IIdentifier>|null = mapItems(value, (ref: IIdentifier|PureModel) => {\\n    if (ref && collection) {\\n      if (ref instanceof PureModel) {\\n        const refType = getModelType(ref);\\n        if (refType !== getModelType(refOptions.model)) {\\n          throw new Error(WRONG_REF_TYPE);\\n        }\\n      }\\n\\n      let instance = collection.find(refOptions.model, ref);\\n      if (!instance && typeof ref === 'object') {\\n        instance = collection.add(ref, refOptions.model);\\n      }\\n\\n      return getModelId(instance || ref);\\n    } else if (ref instanceof PureModel) {\\n      throw error(REF_NEEDS_COLLECTION);\\n    }\\n\\n    return ref;\\n  });\\n\\n  if (refOptions.type === ReferenceType.TO_MANY) {\\n    ids = ids || [];\\n  }\\n\\n  storage.setModelDataKey(model, key, ids);\\n}\\n\\nfunction getModelRefsByType(model: PureModel, type: IType) {\\n  const refs = getModelMetaKey(model, 'refs');\\n\\n  return Object.keys(refs)\\n    .filter((key) => !refs[key].property)\\n    .filter((key) => getModelType(refs[key].model) === type);\\n}\\n\\nfunction updateModelReferences(model: PureModel, newId: IIdentifier, oldId: IIdentifier, type: IType) {\\n  const collection = getModelCollection(model);\\n  if (collection) {\\n    const allModels = collection.getAllModels().map((item) => {\\n      getModelRefsByType(item, type).forEach((ref) => {\\n        const data = storage.getModelDataKey(item, ref);\\n        if (data instanceof Array || isObservableArray(data)) {\\n          const targetIndex = data.indexOf(oldId);\\n          if (targetIndex !== -1) {\\n            data[targetIndex] = newId;\\n          }\\n        } else if (data === oldId) {\\n          storage.setModelDataKey(item, ref, newId);\\n        }\\n      });\\n    });\\n  }\\n}\\n\\n/**\\n * Updates the model identifier and all the existing references to the model\\n *\\n * @export\\n * @param {PureModel} model Model to be updated\\n * @param {IIdentifier} newId New model identifier\\n */\\nexport function updateModelId(model: PureModel, newId: IIdentifier): void {\\n  const collection = getModelCollection(model);\\n\\n  const oldId = getModelId(model);\\n  const type = getModelType(model);\\n  setModelMetaKey(model, 'id', newId);\\n\\n  const staticModel = model.constructor as typeof PureModel;\\n  const modelId = storage.getModelClassMetaKey(staticModel, 'id');\\n  if (modelId) {\\n    setRefId(model, modelId, newId);\\n  }\\n\\n  if (collection) {\\n    // @ts-ignore - I'm bad and I should feel bad...\\n    collection.__changeModelId(oldId, newId, type);\\n  }\\n\\n  updateModelReferences(model, newId, oldId, type);\\n}\\n\\n/**\\n * Get the id of the referenced model\\n *\\n * @export\\n * @param {PureModel} model Source model\\n * @param {string} key Referenced model property name\\n * @returns {IIdentifier} Referenced model id\\n */\\nexport function getRefId(model: PureModel, key: string): IIdentifier|Array<IIdentifier> {\\n  return storage.getModelDataKey(model, key);\\n}\\n\\n/**\\n * Set the id of the referenced model\\n *\\n * @export\\n * @param {PureModel} model Source model\\n * @param {string} key Referenced model property name\\n * @param {IIdentifier} value The new value\\n * @returns {void} Referenced model id\\n */\\nexport function setRefId(model: PureModel, key: string, value: IIdentifier|Array<IIdentifier>): void {\\n  storage.setModelDataKey(model, key, value);\\n}\\n\"]}","dts":{"name":"/Users/darko/Projects/mobx/datx/packages/datx/helpers/model/fields.d.ts","text":"import { FieldType } from '../../enums/FieldType';\r\nimport { IIdentifier } from '../../interfaces/IIdentifier';\r\nimport { TRefValue } from '../../interfaces/TRefValue';\r\nimport { PureModel } from '../../PureModel';\r\nexport declare function getField(model: PureModel, key: string): any;\r\nexport declare function updateField(model: PureModel, key: string, value: any, type: FieldType): void;\r\nexport declare function getRef(model: PureModel, key: string): PureModel | Array<PureModel> | null;\r\nexport declare function updateRef(model: PureModel, key: string, value: TRefValue): void;\r\n/**\r\n * Updates the model identifier and all the existing references to the model\r\n *\r\n * @export\r\n * @param {PureModel} model Model to be updated\r\n * @param {IIdentifier} newId New model identifier\r\n */\r\nexport declare function updateModelId(model: PureModel, newId: IIdentifier): void;\r\n/**\r\n * Get the id of the referenced model\r\n *\r\n * @export\r\n * @param {PureModel} model Source model\r\n * @param {string} key Referenced model property name\r\n * @returns {IIdentifier} Referenced model id\r\n */\r\nexport declare function getRefId(model: PureModel, key: string): IIdentifier | Array<IIdentifier>;\r\n/**\r\n * Set the id of the referenced model\r\n *\r\n * @export\r\n * @param {PureModel} model Source model\r\n * @param {string} key Referenced model property name\r\n * @param {IIdentifier} value The new value\r\n * @returns {void} Referenced model id\r\n */\r\nexport declare function setRefId(model: PureModel, key: string, value: IIdentifier | Array<IIdentifier>): void;\r\n"}}

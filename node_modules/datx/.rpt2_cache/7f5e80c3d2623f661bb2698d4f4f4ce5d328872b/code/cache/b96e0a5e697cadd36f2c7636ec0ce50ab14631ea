{"code":"import { META_FIELD, warn } from 'datx-utils';\r\nimport { toJS } from 'mobx';\r\nimport { NO_REFS, NOT_A_CLONE, REF_NEEDS_COLLECTION } from '../../errors';\r\nimport { PureModel } from '../../PureModel';\r\nimport { storage } from '../../services/storage';\r\nimport { error } from '../format';\r\nimport { initModelField } from '../model/init';\r\n/**\r\n * Get the model type\r\n *\r\n * @export\r\n * @param {(IType|typeof PureModel|PureModel)} model Model to be checked\r\n * @returns {IType} Model type\r\n */\r\nexport function getModelType(model) {\r\n    if (typeof model === 'function') {\r\n        return model.type;\r\n    }\r\n    else if (typeof model === 'object') {\r\n        return getModelMetaKey(model, 'type') || model.constructor.type;\r\n    }\r\n    return model;\r\n}\r\n/**\r\n * Get the model identifier\r\n *\r\n * @export\r\n * @param {(PureModel|IIdentifier)} model Model to be checked\r\n * @returns {IIdentifier} Model identifier\r\n */\r\nexport function getModelId(model) {\r\n    if (model instanceof PureModel) {\r\n        return getModelMetaKey(model, 'id');\r\n    }\r\n    return model;\r\n}\r\n/**\r\n * Get a collection the given model belongs to\r\n *\r\n * @export\r\n * @param {PureModel} model Model to be checked\r\n * @returns {PureCollection} A collection the given model belongs to\r\n */\r\nexport function getModelCollection(model) {\r\n    return getModelMetaKey(model, 'collection');\r\n}\r\n/**\r\n * Clone the given model\r\n *\r\n * @export\r\n * @template T\r\n * @param {T} model Model to be clones\r\n * @returns {T} Cloned model object\r\n */\r\nexport function cloneModel(model) {\r\n    var TypeModel = model.constructor;\r\n    var rawData = modelToJSON(model);\r\n    var meta = rawData[META_FIELD] || {};\r\n    meta.originalId = meta.id;\r\n    delete meta.id;\r\n    var clone = new TypeModel(rawData);\r\n    var collection = getModelCollection(model);\r\n    if (collection) {\r\n        collection.add(clone);\r\n    }\r\n    else {\r\n        warn(\"The model is not in the collection. Referencing the original model won't be possible\");\r\n    }\r\n    return clone;\r\n}\r\n/**\r\n * Get the original model for the cloned model\r\n *\r\n * @export\r\n * @param {PureModel} model Cloned model\r\n * @returns {PureModel} Original model\r\n */\r\nexport function getOriginalModel(model) {\r\n    var collection = getModelCollection(model);\r\n    var originalId = getModelMetaKey(model, 'originalId');\r\n    if (originalId) {\r\n        if (!collection) {\r\n            throw error(REF_NEEDS_COLLECTION);\r\n        }\r\n        return collection.find(model, originalId);\r\n    }\r\n    throw error(NOT_A_CLONE);\r\n}\r\n/**\r\n * Bulk update the model data\r\n *\r\n * @export\r\n * @template T\r\n * @param {T} model Model to be updated\r\n * @param {IDictionary} data Data that should be assigned to the model\r\n * @returns {T}\r\n */\r\nexport function updateModel(model, data) {\r\n    var modelId = storage.getModelClassMetaKey(model.constructor, 'id') || 'id';\r\n    var modelType = storage.getModelClassMetaKey(model.constructor, 'type') || 'type';\r\n    var keys = Object.keys(data instanceof PureModel ? modelToJSON(data) : data);\r\n    keys.forEach(function (key) {\r\n        if (key !== META_FIELD && key !== modelId && key !== modelType) {\r\n            assignModel(model, key, data[key]);\r\n        }\r\n    });\r\n    return model;\r\n}\r\n/**\r\n * Assign a property to a model\r\n *\r\n * @export\r\n * @template T\r\n * @param {T} model A model to modify\r\n * @param {string} key Property name\r\n * @param {*} value Property value\r\n */\r\nexport function assignModel(model, key, value) {\r\n    var refs = getModelMetaKey(model, 'refs');\r\n    if (key in refs) {\r\n        assignModelRef(model, key, value);\r\n    }\r\n    else if (value instanceof PureModel) {\r\n        throw error(NO_REFS, { key: key });\r\n    }\r\n    else {\r\n        assignModelField(model, key, value);\r\n    }\r\n}\r\nfunction assignModelField(model, key, value) {\r\n    var fields = getModelMetaKey(model, 'fields');\r\n    if (fields.indexOf(key) !== -1) {\r\n        model[key] = value;\r\n    }\r\n    else {\r\n        initModelField(model, key, value);\r\n    }\r\n}\r\nfunction assignModelRef(model, key, value) {\r\n    var refs = getModelMetaKey(model, 'refs');\r\n    model[key] = value;\r\n}\r\nexport function getMetaKeyFromRaw(data, key, model) {\r\n    if (META_FIELD in data && typeof data[META_FIELD] === 'object' && data[META_FIELD] !== undefined) {\r\n        return (data[META_FIELD] || {})[key];\r\n    }\r\n    if (model) {\r\n        var modelId = storage.getModelClassMetaKey(model, key);\r\n        return modelId && data[modelId];\r\n    }\r\n    return data && data[key];\r\n}\r\n/**\r\n * Get a serializable value of the model\r\n *\r\n * @export\r\n * @param {PureModel} model Model to serialize\r\n * @returns {IRawModel} Pure JS value of the model\r\n */\r\nexport function modelToJSON(model) {\r\n    var data = toJS(storage.getModelData(model));\r\n    var rawMeta = Object.assign({}, storage.getModelMeta(model));\r\n    delete rawMeta.collection;\r\n    var meta = toJS(rawMeta);\r\n    delete meta.collection;\r\n    var raw = Object.assign(data, (_a = {}, _a[META_FIELD] = meta, _a));\r\n    var staticModel = model.constructor;\r\n    var modelId = storage.getModelClassMetaKey(staticModel, 'id');\r\n    var modelType = storage.getModelClassMetaKey(staticModel, 'type');\r\n    if (meta && modelId) {\r\n        raw[modelId] = meta.id;\r\n    }\r\n    if (meta && modelType) {\r\n        raw[modelType] = meta.type;\r\n    }\r\n    return raw;\r\n    var _a;\r\n}\r\nexport function getModelMetaKey(model, key) {\r\n    return storage.getModelMetaKey(model, key);\r\n}\r\nexport function setModelMetaKey(model, key, value) {\r\n    storage.setModelMetaKey(model, key, value);\r\n    return;\r\n}\r\n//# sourceMappingURL=utils.js.map","map":"{\"version\":3,\"file\":\"utils.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../src/helpers/model/utils.ts\"],\"names\":[],\"mappings\":\"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\",\"sourcesContent\":[\"import {IDictionary, IRawModel, META_FIELD, warn} from 'datx-utils';\\nimport {toJS} from 'mobx';\\n\\nimport {NO_REFS, NOT_A_CLONE, REF_NEEDS_COLLECTION} from '../../errors';\\nimport {IIdentifier} from '../../interfaces/IIdentifier';\\nimport {IReferenceOptions} from '../../interfaces/IReferenceOptions';\\nimport {IType} from '../../interfaces/IType';\\nimport {TRefValue} from '../../interfaces/TRefValue';\\nimport {PureCollection} from '../../PureCollection';\\nimport {PureModel} from '../../PureModel';\\nimport {storage} from '../../services/storage';\\nimport {error} from '../format';\\nimport {initModelField} from '../model/init';\\n\\n/**\\n * Get the model type\\n *\\n * @export\\n * @param {(IType|typeof PureModel|PureModel)} model Model to be checked\\n * @returns {IType} Model type\\n */\\nexport function getModelType(model: IType|typeof PureModel|PureModel): IType {\\n  if (typeof model === 'function') {\\n    return model.type;\\n  } else if (typeof model === 'object') {\\n    return getModelMetaKey(model, 'type') || (model.constructor as typeof PureModel).type;\\n  }\\n\\n  return model;\\n}\\n\\n/**\\n * Get the model identifier\\n *\\n * @export\\n * @param {(PureModel|IIdentifier)} model Model to be checked\\n * @returns {IIdentifier} Model identifier\\n */\\nexport function getModelId(model: PureModel|IIdentifier): IIdentifier {\\n  if (model instanceof PureModel) {\\n    return getModelMetaKey(model, 'id');\\n  }\\n\\n  return model;\\n}\\n\\n/**\\n * Get a collection the given model belongs to\\n *\\n * @export\\n * @param {PureModel} model Model to be checked\\n * @returns {PureCollection} A collection the given model belongs to\\n */\\nexport function getModelCollection(model: PureModel): PureCollection|undefined {\\n  return getModelMetaKey(model, 'collection');\\n}\\n\\n/**\\n * Clone the given model\\n *\\n * @export\\n * @template T\\n * @param {T} model Model to be clones\\n * @returns {T} Cloned model object\\n */\\nexport function cloneModel<T extends PureModel>(model: T): T {\\n  const TypeModel = model.constructor as typeof PureModel;\\n  const rawData = modelToJSON(model);\\n  const meta = rawData[META_FIELD] || {};\\n  meta.originalId = meta.id;\\n  delete meta.id;\\n\\n  const clone = new TypeModel(rawData) as T;\\n\\n  const collection = getModelCollection(model);\\n  if (collection) {\\n    collection.add(clone);\\n  } else {\\n    warn(`The model is not in the collection. Referencing the original model won't be possible`);\\n  }\\n\\n  return clone;\\n}\\n\\n/**\\n * Get the original model for the cloned model\\n *\\n * @export\\n * @param {PureModel} model Cloned model\\n * @returns {PureModel} Original model\\n */\\nexport function getOriginalModel(model: PureModel): PureModel {\\n  const collection = getModelCollection(model);\\n  const originalId = getModelMetaKey(model, 'originalId');\\n  if (originalId) {\\n    if (!collection) {\\n      throw error(REF_NEEDS_COLLECTION);\\n    }\\n\\n    return collection.find(model, originalId) as PureModel;\\n  }\\n  throw error(NOT_A_CLONE);\\n}\\n\\n/**\\n * Bulk update the model data\\n *\\n * @export\\n * @template T\\n * @param {T} model Model to be updated\\n * @param {IDictionary} data Data that should be assigned to the model\\n * @returns {T}\\n */\\nexport function updateModel<T extends PureModel>(model: T, data: IDictionary): T {\\n  const modelId = storage.getModelClassMetaKey(model.constructor as typeof PureModel, 'id') || 'id';\\n  const modelType = storage.getModelClassMetaKey(model.constructor as typeof PureModel, 'type') || 'type';\\n\\n  const keys = Object.keys(data instanceof PureModel ? modelToJSON(data) : data);\\n  keys.forEach((key) => {\\n    if (key !== META_FIELD && key !== modelId && key !== modelType) {\\n      assignModel(model, key, data[key]);\\n    }\\n  });\\n\\n  return model;\\n}\\n\\n/**\\n * Assign a property to a model\\n *\\n * @export\\n * @template T\\n * @param {T} model A model to modify\\n * @param {string} key Property name\\n * @param {*} value Property value\\n */\\nexport function assignModel<T extends PureModel>(model: T, key: string, value: any): void {\\n  const refs = getModelMetaKey(model, 'refs') as IDictionary<IReferenceOptions>;\\n  if (key in refs) {\\n    assignModelRef(model, key, value);\\n  } else if (value instanceof PureModel) {\\n    throw error(NO_REFS, {key});\\n  } else {\\n    assignModelField(model, key, value);\\n  }\\n}\\n\\nfunction assignModelField<T extends PureModel>(model: T, key: string, value: any): void {\\n  const fields = getModelMetaKey(model, 'fields') as Array<string>;\\n  if (fields.indexOf(key) !== -1) {\\n    model[key] = value;\\n  } else {\\n    initModelField(model, key, value);\\n  }\\n}\\n\\nfunction assignModelRef<T extends PureModel>(model: T, key: string, value: TRefValue): void {\\n  const refs = getModelMetaKey(model, 'refs');\\n  model[key] = value;\\n}\\n\\nexport function getMetaKeyFromRaw(data: IRawModel, key: string, model?: typeof PureModel): any {\\n  if (META_FIELD in data && typeof data[META_FIELD] === 'object' && data[META_FIELD] !== undefined) {\\n    return (data[META_FIELD] || {})[key];\\n  }\\n  if (model) {\\n    const modelId = storage.getModelClassMetaKey(model, key);\\n\\n    return modelId && data[modelId];\\n  }\\n\\n  return data && data[key];\\n}\\n\\n/**\\n * Get a serializable value of the model\\n *\\n * @export\\n * @param {PureModel} model Model to serialize\\n * @returns {IRawModel} Pure JS value of the model\\n */\\nexport function modelToJSON(model: PureModel): IRawModel {\\n  const data = toJS(storage.getModelData(model));\\n\\n  const rawMeta = Object.assign({}, storage.getModelMeta(model));\\n  delete rawMeta.collection;\\n  const meta = toJS(rawMeta);\\n\\n  delete meta.collection;\\n\\n  const raw = Object.assign(data, {[META_FIELD]: meta});\\n\\n  const staticModel = model.constructor as typeof PureModel;\\n  const modelId = storage.getModelClassMetaKey(staticModel, 'id');\\n  const modelType = storage.getModelClassMetaKey(staticModel, 'type');\\n  if (meta && modelId) {\\n    raw[modelId] = meta.id;\\n  }\\n  if (meta && modelType) {\\n    raw[modelType] = meta.type;\\n  }\\n\\n  return raw;\\n}\\n\\nexport function getModelMetaKey(model: PureModel, key: string) {\\n  return storage.getModelMetaKey(model, key);\\n}\\n\\nexport function setModelMetaKey(model: PureModel, key: string, value: any) {\\n  storage.setModelMetaKey(model, key, value);\\n\\n  return;\\n}\\n\"]}","dts":{"name":"/Users/darko/Projects/mobx/datx/packages/datx/helpers/model/utils.d.ts","text":"import { IDictionary, IRawModel } from 'datx-utils';\r\nimport { IIdentifier } from '../../interfaces/IIdentifier';\r\nimport { IType } from '../../interfaces/IType';\r\nimport { PureCollection } from '../../PureCollection';\r\nimport { PureModel } from '../../PureModel';\r\n/**\r\n * Get the model type\r\n *\r\n * @export\r\n * @param {(IType|typeof PureModel|PureModel)} model Model to be checked\r\n * @returns {IType} Model type\r\n */\r\nexport declare function getModelType(model: IType | typeof PureModel | PureModel): IType;\r\n/**\r\n * Get the model identifier\r\n *\r\n * @export\r\n * @param {(PureModel|IIdentifier)} model Model to be checked\r\n * @returns {IIdentifier} Model identifier\r\n */\r\nexport declare function getModelId(model: PureModel | IIdentifier): IIdentifier;\r\n/**\r\n * Get a collection the given model belongs to\r\n *\r\n * @export\r\n * @param {PureModel} model Model to be checked\r\n * @returns {PureCollection} A collection the given model belongs to\r\n */\r\nexport declare function getModelCollection(model: PureModel): PureCollection | undefined;\r\n/**\r\n * Clone the given model\r\n *\r\n * @export\r\n * @template T\r\n * @param {T} model Model to be clones\r\n * @returns {T} Cloned model object\r\n */\r\nexport declare function cloneModel<T extends PureModel>(model: T): T;\r\n/**\r\n * Get the original model for the cloned model\r\n *\r\n * @export\r\n * @param {PureModel} model Cloned model\r\n * @returns {PureModel} Original model\r\n */\r\nexport declare function getOriginalModel(model: PureModel): PureModel;\r\n/**\r\n * Bulk update the model data\r\n *\r\n * @export\r\n * @template T\r\n * @param {T} model Model to be updated\r\n * @param {IDictionary} data Data that should be assigned to the model\r\n * @returns {T}\r\n */\r\nexport declare function updateModel<T extends PureModel>(model: T, data: IDictionary): T;\r\n/**\r\n * Assign a property to a model\r\n *\r\n * @export\r\n * @template T\r\n * @param {T} model A model to modify\r\n * @param {string} key Property name\r\n * @param {*} value Property value\r\n */\r\nexport declare function assignModel<T extends PureModel>(model: T, key: string, value: any): void;\r\nexport declare function getMetaKeyFromRaw(data: IRawModel, key: string, model?: typeof PureModel): any;\r\n/**\r\n * Get a serializable value of the model\r\n *\r\n * @export\r\n * @param {PureModel} model Model to serialize\r\n * @returns {IRawModel} Pure JS value of the model\r\n */\r\nexport declare function modelToJSON(model: PureModel): IRawModel;\r\nexport declare function getModelMetaKey(model: PureModel, key: string): any;\r\nexport declare function setModelMetaKey(model: PureModel, key: string, value: any): void;\r\n"}}

{"code":"import { assignComputed, META_FIELD } from 'datx-utils';\r\nimport { FieldType } from '../../enums/FieldType';\r\nimport { ReferenceType } from '../../enums/ReferenceType';\r\nimport { ID_REQUIRED } from '../../errors';\r\nimport { storage } from '../../services/storage';\r\nimport { getField, getRef, updateField, updateRef } from './fields';\r\nimport { getModelMetaKey, getModelType, setModelMetaKey } from './utils';\r\nexport function initModelField(obj, key, defValue, type) {\r\n    if (type === void 0) { type = FieldType.DATA; }\r\n    var fields = getModelMetaKey(obj, 'fields');\r\n    if (type === FieldType.ID && key in obj) {\r\n        delete obj[key];\r\n    }\r\n    // Initialize the observable field to the default value\r\n    storage.setModelDataKey(obj, key, defValue);\r\n    if (fields.indexOf(key) === -1) {\r\n        fields.push(key);\r\n    }\r\n    assignComputed(obj, key, function () { return getField(obj, key); }, function (value) {\r\n        updateField(obj, key, value, type);\r\n    });\r\n}\r\n/**\r\n * Initialize a reference to other models\r\n *\r\n * @export\r\n * @param {PureModel} obj Model to which the reference should be added\r\n * @param {string} key Model property where the reference will be defined\r\n * @param {IReferenceOptions} options Reference options\r\n * @param {TRefValue} initialVal Initial reference value\r\n */\r\nexport function initModelRef(obj, key, options, initialVal) {\r\n    var refs = getModelMetaKey(obj, 'refs');\r\n    // Initialize the observable field to the given value\r\n    refs[key] = options;\r\n    var isArray = options.type === ReferenceType.TO_MANY;\r\n    storage.setModelDataKey(obj, key, isArray ? [] : undefined);\r\n    assignComputed(obj, key, function () { return getRef(obj, key); }, function (value) {\r\n        updateRef(obj, key, value);\r\n    });\r\n    if (!options.property && initialVal !== undefined) {\r\n        obj[key] = initialVal;\r\n    }\r\n}\r\nfunction prepareFields(data, meta, model) {\r\n    var staticModel = model.constructor;\r\n    var fields = meta.fields ? meta.fields.slice() : [];\r\n    var classRefs = storage.getModelClassReferences(staticModel);\r\n    var refs = Object.assign({}, classRefs, meta.refs);\r\n    var defaults = storage.getModelDefaults(staticModel);\r\n    Object.keys(data).concat(Object.keys(defaults))\r\n        .forEach(function (key) {\r\n        if (!(key in refs) && fields.indexOf(key) === -1) {\r\n            fields.push(key);\r\n        }\r\n    });\r\n    return { defaults: defaults, fields: fields, refs: refs };\r\n}\r\nfunction initModelData(model, data, meta, collection) {\r\n    var _a = prepareFields(data, meta, model), defaults = _a.defaults, fields = _a.fields, refs = _a.refs;\r\n    var staticModel = model.constructor;\r\n    var modelId = storage.getModelClassMetaKey(staticModel, 'id');\r\n    var modelType = storage.getModelClassMetaKey(staticModel, 'type');\r\n    fields.forEach(function (key) {\r\n        var type = FieldType.DATA;\r\n        var value = data[key];\r\n        if (value === undefined) {\r\n            value = defaults[key];\r\n        }\r\n        if (key === (modelId || 'id')) {\r\n            type = FieldType.ID;\r\n            value = meta.id;\r\n        }\r\n        else if (key === modelType) {\r\n            type = FieldType.TYPE;\r\n            value = meta.type;\r\n        }\r\n        initModelField(model, key, value, type);\r\n    });\r\n    if (modelId && !(modelId in fields)) {\r\n        initModelField(model, modelId, meta.id, FieldType.ID);\r\n    }\r\n    Object.keys(refs).forEach(function (key) {\r\n        var opts = refs[key];\r\n        var value = data[key] || defaults[key] || undefined;\r\n        var models = collection ? collection.add(value, getModelType(opts.model)) : value;\r\n        initModelRef(model, key, opts, models);\r\n    });\r\n}\r\nfunction initModelMeta(model, data, collection) {\r\n    var staticModel = model.constructor;\r\n    var modelId = storage.getModelClassMetaKey(staticModel, 'id') || 'id';\r\n    var modelType = storage.getModelClassMetaKey(staticModel, 'type');\r\n    var type = (modelType && data[modelType]) || getModelType(model);\r\n    var id = (modelId && data[modelId]);\r\n    if (!id) {\r\n        if (!staticModel.enableAutoId) {\r\n            throw new Error(ID_REQUIRED);\r\n        }\r\n        id = staticModel.getAutoId();\r\n        while (collection && collection.find(type, id)) {\r\n            id = staticModel.getAutoId();\r\n        }\r\n    }\r\n    var meta = {\r\n        fields: [],\r\n        id: id,\r\n        refs: {},\r\n        type: type,\r\n    };\r\n    var newMeta;\r\n    var toInit = { fields: [], refs: {} };\r\n    if (META_FIELD in data && data[META_FIELD]) {\r\n        var oldMeta = data[META_FIELD] || {};\r\n        toInit.fields = oldMeta.fields;\r\n        delete oldMeta.fields;\r\n        toInit.refs = oldMeta.refs;\r\n        delete oldMeta.refs;\r\n        newMeta = storage.setModelMeta(model, Object.assign(meta, oldMeta));\r\n        delete data[META_FIELD];\r\n    }\r\n    else {\r\n        newMeta = storage.setModelMeta(model, meta);\r\n    }\r\n    return Object.assign({}, newMeta, toInit);\r\n}\r\nexport function initModel(model, rawData, collection) {\r\n    var staticModel = model.constructor;\r\n    var data = Object.assign({}, staticModel.preprocess(rawData, collection));\r\n    setModelMetaKey(model, 'collection', collection);\r\n    var meta = initModelMeta(model, data, collection);\r\n    initModelData(model, data, meta, collection);\r\n}\r\n//# sourceMappingURL=init.js.map","map":"{\"version\":3,\"file\":\"init.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../src/helpers/model/init.ts\"],\"names\":[],\"mappings\":\"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\",\"sourcesContent\":[\"import {assignComputed, IDictionary, IRawModel, META_FIELD} from 'datx-utils';\\n\\nimport {FieldType} from '../../enums/FieldType';\\nimport {ReferenceType} from '../../enums/ReferenceType';\\nimport {ID_REQUIRED, MODEL_EXISTS} from '../../errors';\\nimport {IIdentifier} from '../../interfaces/IIdentifier';\\nimport {IReferenceOptions} from '../../interfaces/IReferenceOptions';\\nimport {IType} from '../../interfaces/IType';\\nimport {TRefValue} from '../../interfaces/TRefValue';\\nimport {PureCollection} from '../../PureCollection';\\nimport {PureModel} from '../../PureModel';\\nimport {storage} from '../../services/storage';\\nimport {error} from '../format';\\nimport {getField, getRef, updateField, updateRef} from './fields';\\nimport {getModelMetaKey, getModelType, setModelMetaKey} from './utils';\\n\\ninterface IMetaToInit extends IDictionary {\\n  fields: Array<string>;\\n  id?: IIdentifier;\\n  refs: IDictionary<IReferenceOptions>;\\n  type?: IType;\\n}\\n\\nexport function initModelField<T extends PureModel>(\\n  obj: T,\\n  key: string,\\n  defValue: any,\\n  type: FieldType = FieldType.DATA,\\n) {\\n  const fields = getModelMetaKey(obj, 'fields') as Array<string>;\\n\\n  if (type === FieldType.ID && key in obj) {\\n    delete obj[key];\\n  }\\n\\n  // Initialize the observable field to the default value\\n  storage.setModelDataKey(obj, key, defValue);\\n  if (fields.indexOf(key) === -1) {\\n    fields.push(key);\\n  }\\n\\n  assignComputed(obj, key,\\n    () => getField(obj, key),\\n    (value) => {\\n      updateField(obj, key, value, type);\\n    },\\n  );\\n}\\n\\n/**\\n * Initialize a reference to other models\\n *\\n * @export\\n * @param {PureModel} obj Model to which the reference should be added\\n * @param {string} key Model property where the reference will be defined\\n * @param {IReferenceOptions} options Reference options\\n * @param {TRefValue} initialVal Initial reference value\\n */\\nexport function initModelRef(obj: PureModel, key: string, options: IReferenceOptions, initialVal: TRefValue) {\\n  const refs = getModelMetaKey(obj, 'refs');\\n\\n  // Initialize the observable field to the given value\\n  refs[key] = options;\\n\\n  const isArray = options.type === ReferenceType.TO_MANY;\\n  storage.setModelDataKey(obj, key, isArray ? [] : undefined);\\n\\n  assignComputed(obj, key,\\n    () => getRef(obj, key),\\n    (value) => {\\n      updateRef(obj, key, value);\\n    },\\n  );\\n\\n  if (!options.property && initialVal !== undefined) {\\n    obj[key] = initialVal;\\n  }\\n}\\n\\nfunction prepareFields(data: IRawModel, meta: IMetaToInit, model: PureModel) {\\n  const staticModel = model.constructor as typeof PureModel;\\n  const fields = meta.fields ? meta.fields.slice() : [];\\n  const classRefs = storage.getModelClassReferences(staticModel);\\n  const refs = Object.assign({}, classRefs, meta.refs);\\n\\n  const defaults = storage.getModelDefaults(staticModel);\\n\\n  Object.keys(data).concat(Object.keys(defaults))\\n    .forEach((key) => {\\n      if (!(key in refs) && fields.indexOf(key) === -1) {\\n        fields.push(key);\\n      }\\n    });\\n\\n  return {defaults, fields, refs};\\n}\\n\\nfunction initModelData(model: PureModel, data: IRawModel, meta: IMetaToInit, collection?: PureCollection) {\\n  const {defaults, fields, refs} = prepareFields(data, meta, model);\\n\\n  const staticModel = model.constructor as typeof PureModel;\\n  const modelId = storage.getModelClassMetaKey(staticModel, 'id');\\n  const modelType = storage.getModelClassMetaKey(staticModel, 'type');\\n\\n  fields.forEach((key) => {\\n    let type = FieldType.DATA;\\n    let value = data[key];\\n    if (value === undefined) {\\n      value = defaults[key];\\n    }\\n    if (key === (modelId || 'id')) {\\n      type = FieldType.ID;\\n      value = meta.id;\\n    } else if (key === modelType) {\\n      type = FieldType.TYPE;\\n      value = meta.type;\\n    }\\n    initModelField(model, key, value, type);\\n  });\\n\\n  if (modelId && !(modelId in fields)) {\\n    initModelField(model, modelId, meta.id, FieldType.ID);\\n  }\\n\\n  Object.keys(refs).forEach((key) => {\\n    const opts = refs[key];\\n    const value = data[key] || defaults[key] || undefined;\\n    const models: any = collection ? collection.add(value, getModelType(opts.model)) : value;\\n    initModelRef(model, key, opts, models);\\n  });\\n}\\n\\nfunction initModelMeta(model: PureModel, data: IRawModel, collection?: PureCollection): IDictionary & IMetaToInit {\\n  const staticModel = model.constructor as typeof PureModel;\\n  const modelId = storage.getModelClassMetaKey(staticModel, 'id') || 'id';\\n  const modelType = storage.getModelClassMetaKey(staticModel, 'type');\\n\\n  const type = (modelType && data[modelType]) || getModelType(model);\\n  let id = (modelId && data[modelId]);\\n\\n  if (!id) {\\n    if (!staticModel.enableAutoId) {\\n      throw new Error(ID_REQUIRED);\\n    }\\n    id = staticModel.getAutoId();\\n    while (collection && collection.find(type, id)) {\\n      id = staticModel.getAutoId();\\n    }\\n  }\\n\\n  const meta = {\\n    fields: [],\\n    id,\\n    refs: {},\\n    type,\\n  };\\n\\n  let newMeta;\\n  const toInit: IMetaToInit = {fields: [], refs: {}};\\n  if (META_FIELD in data && data[META_FIELD]) {\\n    const oldMeta = data[META_FIELD] || {};\\n    toInit.fields = oldMeta.fields;\\n    delete oldMeta.fields;\\n    toInit.refs = oldMeta.refs;\\n    delete oldMeta.refs;\\n\\n    newMeta = storage.setModelMeta(model, Object.assign(meta, oldMeta));\\n    delete data[META_FIELD];\\n  } else {\\n    newMeta = storage.setModelMeta(model, meta);\\n  }\\n\\n  return Object.assign({}, newMeta, toInit);\\n}\\n\\nexport function initModel(model: PureModel, rawData: IRawModel, collection?: PureCollection) {\\n  const staticModel = model.constructor as typeof PureModel;\\n  const data = Object.assign({}, staticModel.preprocess(rawData, collection));\\n  setModelMetaKey(model, 'collection', collection);\\n  const meta = initModelMeta(model, data, collection);\\n  initModelData(model, data, meta, collection);\\n}\\n\"]}","dts":{"name":"/Users/darko/Projects/mobx/datx/packages/datx/helpers/model/init.d.ts","text":"import { IRawModel } from 'datx-utils';\r\nimport { FieldType } from '../../enums/FieldType';\r\nimport { IReferenceOptions } from '../../interfaces/IReferenceOptions';\r\nimport { TRefValue } from '../../interfaces/TRefValue';\r\nimport { PureCollection } from '../../PureCollection';\r\nimport { PureModel } from '../../PureModel';\r\nexport declare function initModelField<T extends PureModel>(obj: T, key: string, defValue: any, type?: FieldType): void;\r\n/**\r\n * Initialize a reference to other models\r\n *\r\n * @export\r\n * @param {PureModel} obj Model to which the reference should be added\r\n * @param {string} key Model property where the reference will be defined\r\n * @param {IReferenceOptions} options Reference options\r\n * @param {TRefValue} initialVal Initial reference value\r\n */\r\nexport declare function initModelRef(obj: PureModel, key: string, options: IReferenceOptions, initialVal: TRefValue): void;\r\nexport declare function initModel(model: PureModel, rawData: IRawModel, collection?: PureCollection): void;\r\n"}}

{"code":"import { mapItems, warn } from 'datx-utils';\r\nimport { intercept, isObservableArray, observable } from 'mobx';\r\nimport { FieldType } from '../../enums/FieldType';\r\nimport { ReferenceType } from '../../enums/ReferenceType';\r\nimport { BACK_REF_READ_ONLY, ID_READONLY, REF_ARRAY, REF_NEEDS_COLLECTION, REF_SINGLE, TYPE_READONLY, WRONG_REF_TYPE, } from '../../errors';\r\nimport { PureModel } from '../../PureModel';\r\nimport { storage } from '../../services/storage';\r\nimport { error } from '../format';\r\nimport { getModelCollection, getModelId, getModelMetaKey, getModelType, setModelMetaKey } from './utils';\r\nfunction modelAddReference(model, key, newReference) {\r\n    var refOptions = storage.getModelReferenceOptions(model, key);\r\n    var newRefId = getModelId(newReference);\r\n    var data = storage.getModelDataKey(model, key);\r\n    if (refOptions.type === ReferenceType.TO_ONE) {\r\n        storage.setModelDataKey(model, key, newRefId);\r\n    }\r\n    else if (refOptions.type === ReferenceType.TO_MANY || isObservableArray(data)) {\r\n        data.push(newRefId);\r\n    }\r\n    else {\r\n        storage.setModelDataKey(model, key, newReference);\r\n    }\r\n}\r\nfunction modelRemoveReference(model, key, oldReference) {\r\n    var refOptions = storage.getModelReferenceOptions(model, key);\r\n    var oldRefId = getModelId(oldReference);\r\n    var data = storage.getModelDataKey(model, key);\r\n    if (refOptions.type === ReferenceType.TO_ONE) {\r\n        storage.setModelDataKey(model, key, null);\r\n    }\r\n    else if (refOptions.type === ReferenceType.TO_MANY || isObservableArray(data)) {\r\n        data.remove(oldRefId);\r\n    }\r\n    else {\r\n        storage.setModelDataKey(model, key, null);\r\n    }\r\n}\r\nfunction ensureModel(refOptions, collection) {\r\n    return function (data) {\r\n        var model = data;\r\n        if (!(data instanceof PureModel) && typeof data === 'object') {\r\n            if (!collection) {\r\n                throw new Error(REF_NEEDS_COLLECTION);\r\n            }\r\n            model = collection.add(data, refOptions.model);\r\n        }\r\n        return getModelId(model);\r\n    };\r\n}\r\nfunction partialRefUpdate(model, key, change) {\r\n    var refOptions = storage.getModelReferenceOptions(model, key);\r\n    var data = storage.getModelDataKey(model, key);\r\n    var collection = getModelCollection(model);\r\n    if (change.type === 'splice') {\r\n        var added = change.added.map(ensureModel(refOptions, collection));\r\n        data.splice.apply(data, [change.index, change.removedCount].concat(added));\r\n        return null;\r\n    }\r\n    data[change.index] = ensureModel(refOptions, collection)(change.newValue);\r\n    return null;\r\n}\r\nfunction backRefSplice(model, key, change, refOptions) {\r\n    var property = refOptions.property;\r\n    change.added.forEach(function (item) {\r\n        modelAddReference(item, property, model);\r\n    });\r\n    var removed = model[key].slice(change.index, change.index + change.removedCount);\r\n    removed.forEach(function (item) {\r\n        modelRemoveReference(item, property, model);\r\n    });\r\n    return null;\r\n}\r\nfunction backRefChange(model, key, change, refOptions) {\r\n    var property = refOptions.property;\r\n    var oldValue = model[key].length > change.index ? model[key][change.index] : null;\r\n    if (change.newValue) {\r\n        modelAddReference(change.newValue, property, model);\r\n    }\r\n    if (oldValue) {\r\n        modelRemoveReference(oldValue, property, model);\r\n    }\r\n    warn(\"This shouldn't have happened. Please open an issue: https://github.com/infinum/datx/issues/new\");\r\n    return null;\r\n}\r\nfunction partialBackRefUpdate(model, key, change) {\r\n    var refOptions = storage.getModelReferenceOptions(model, key);\r\n    if (change.type === 'splice') {\r\n        return backRefSplice(model, key, change, refOptions);\r\n    }\r\n    return backRefChange(model, key, change, refOptions);\r\n}\r\nexport function getField(model, key) {\r\n    return storage.getModelDataKey(model, key);\r\n}\r\nexport function updateField(model, key, value, type) {\r\n    if (type === FieldType.TYPE) {\r\n        throw error(TYPE_READONLY);\r\n    }\r\n    else if (type === FieldType.ID) {\r\n        throw error(ID_READONLY);\r\n    }\r\n    var refs = getModelMetaKey(model, 'refs');\r\n    if (key in refs) {\r\n        updateRef(model, key, value);\r\n    }\r\n    else {\r\n        storage.setModelDataKey(model, key, value);\r\n    }\r\n}\r\nfunction hasBackRef(item, property, target) {\r\n    if (item[property] === null || item[property] === undefined) {\r\n        return false;\r\n    }\r\n    else if (item[property] instanceof PureModel) {\r\n        return item[property] === target;\r\n    }\r\n    else {\r\n        return item[property].indexOf(target) !== -1;\r\n    }\r\n}\r\nfunction getBackRef(model, key, refOptions) {\r\n    var type = getModelType(refOptions.model);\r\n    var collection = getModelCollection(model);\r\n    if (!collection) {\r\n        return null;\r\n    }\r\n    var backModels = collection\r\n        .findAll(type)\r\n        .filter(function (item) { return hasBackRef(item, refOptions.property, model); });\r\n    var backData = observable.array(backModels, { deep: false });\r\n    intercept(backData, function (change) { return partialBackRefUpdate(model, key, change); });\r\n    return backData;\r\n}\r\nfunction getNormalRef(model, key, refOptions) {\r\n    var value = storage.getModelDataKey(model, key);\r\n    var collection = getModelCollection(model);\r\n    if (!collection) {\r\n        return null;\r\n    }\r\n    var dataModels = mapItems(value, function (id) { return id ? collection.find(refOptions.model, id) : id; });\r\n    if (refOptions.type === ReferenceType.TO_MANY && !(dataModels instanceof Array)) {\r\n        dataModels = [dataModels];\r\n    }\r\n    if (dataModels instanceof Array) {\r\n        var data = observable.array(dataModels, { deep: false });\r\n        intercept(data, function (change) { return partialRefUpdate(model, key, change); });\r\n        return data;\r\n    }\r\n    return dataModels;\r\n}\r\nexport function getRef(model, key) {\r\n    var refOptions = storage.getModelReferenceOptions(model, key);\r\n    return (typeof refOptions.property === 'string')\r\n        ? getBackRef(model, key, refOptions)\r\n        : getNormalRef(model, key, refOptions);\r\n}\r\nfunction validateRef(refOptions, isArray, key) {\r\n    if (refOptions.type === ReferenceType.TO_ONE && isArray) {\r\n        throw error(REF_SINGLE, { key: key });\r\n    }\r\n    else if (refOptions.type === ReferenceType.TO_MANY && !isArray) {\r\n        throw error(REF_ARRAY, { key: key });\r\n    }\r\n    else if (refOptions.property) {\r\n        throw error(BACK_REF_READ_ONLY);\r\n    }\r\n}\r\nexport function updateRef(model, key, value) {\r\n    var refOptions = storage.getModelReferenceOptions(model, key);\r\n    var check = refOptions.type === ReferenceType.TO_MANY ? value || [] : value;\r\n    var isArray = check instanceof Array || isObservableArray(check);\r\n    validateRef(refOptions, isArray, key);\r\n    var collection = getModelCollection(model);\r\n    var ids = mapItems(value, function (ref) {\r\n        if (ref && collection) {\r\n            if (ref instanceof PureModel) {\r\n                var refType = getModelType(ref);\r\n                if (refType !== getModelType(refOptions.model)) {\r\n                    throw new Error(WRONG_REF_TYPE);\r\n                }\r\n            }\r\n            var instance = collection.find(refOptions.model, ref);\r\n            if (!instance && typeof ref === 'object') {\r\n                instance = collection.add(ref, refOptions.model);\r\n            }\r\n            return getModelId(instance || ref);\r\n        }\r\n        else if (ref instanceof PureModel) {\r\n            throw error(REF_NEEDS_COLLECTION);\r\n        }\r\n        return ref;\r\n    });\r\n    if (refOptions.type === ReferenceType.TO_MANY) {\r\n        ids = ids || [];\r\n    }\r\n    storage.setModelDataKey(model, key, ids);\r\n}\r\nfunction getModelRefsByType(model, type) {\r\n    var refs = getModelMetaKey(model, 'refs');\r\n    return Object.keys(refs)\r\n        .filter(function (key) { return !refs[key].property; })\r\n        .filter(function (key) { return getModelType(refs[key].model) === type; });\r\n}\r\nfunction updateModelReferences(model, newId, oldId, type) {\r\n    var collection = getModelCollection(model);\r\n    if (collection) {\r\n        var allModels = collection.getAllModels().map(function (item) {\r\n            getModelRefsByType(item, type).forEach(function (ref) {\r\n                var data = storage.getModelDataKey(item, ref);\r\n                if (data instanceof Array || isObservableArray(data)) {\r\n                    var targetIndex = data.indexOf(oldId);\r\n                    if (targetIndex !== -1) {\r\n                        data[targetIndex] = newId;\r\n                    }\r\n                }\r\n                else if (data === oldId) {\r\n                    storage.setModelDataKey(item, ref, newId);\r\n                }\r\n            });\r\n        });\r\n    }\r\n}\r\n/**\r\n * Updates the model identifier and all the existing references to the model\r\n *\r\n * @export\r\n * @param {PureModel} model Model to be updated\r\n * @param {IIdentifier} newId New model identifier\r\n */\r\nexport function updateModelId(model, newId) {\r\n    var collection = getModelCollection(model);\r\n    var oldId = getModelId(model);\r\n    var type = getModelType(model);\r\n    setModelMetaKey(model, 'id', newId);\r\n    var staticModel = model.constructor;\r\n    var modelId = storage.getModelClassMetaKey(staticModel, 'id');\r\n    if (modelId) {\r\n        setRefId(model, modelId, newId);\r\n    }\r\n    if (collection) {\r\n        // @ts-ignore - I'm bad and I should feel bad...\r\n        collection.__changeModelId(oldId, newId, type);\r\n    }\r\n    updateModelReferences(model, newId, oldId, type);\r\n}\r\n/**\r\n * Get the id of the referenced model\r\n *\r\n * @export\r\n * @param {PureModel} model Source model\r\n * @param {string} key Referenced model property name\r\n * @returns {IIdentifier} Referenced model id\r\n */\r\nexport function getRefId(model, key) {\r\n    return storage.getModelDataKey(model, key);\r\n}\r\n/**\r\n * Set the id of the referenced model\r\n *\r\n * @export\r\n * @param {PureModel} model Source model\r\n * @param {string} key Referenced model property name\r\n * @param {IIdentifier} value The new value\r\n * @returns {void} Referenced model id\r\n */\r\nexport function setRefId(model, key, value) {\r\n    storage.setModelDataKey(model, key, value);\r\n}\r\n","dts":{"name":"/Users/darko/Projects/mobx/datx/packages/datx/helpers/model/fields.d.ts","text":"import { FieldType } from '../../enums/FieldType';\r\nimport { IIdentifier } from '../../interfaces/IIdentifier';\r\nimport { TRefValue } from '../../interfaces/TRefValue';\r\nimport { PureModel } from '../../PureModel';\r\nexport declare function getField(model: PureModel, key: string): any;\r\nexport declare function updateField(model: PureModel, key: string, value: any, type: FieldType): void;\r\nexport declare function getRef(model: PureModel, key: string): PureModel | Array<PureModel> | null;\r\nexport declare function updateRef(model: PureModel, key: string, value: TRefValue): void;\r\n/**\r\n * Updates the model identifier and all the existing references to the model\r\n *\r\n * @export\r\n * @param {PureModel} model Model to be updated\r\n * @param {IIdentifier} newId New model identifier\r\n */\r\nexport declare function updateModelId(model: PureModel, newId: IIdentifier): void;\r\n/**\r\n * Get the id of the referenced model\r\n *\r\n * @export\r\n * @param {PureModel} model Source model\r\n * @param {string} key Referenced model property name\r\n * @returns {IIdentifier} Referenced model id\r\n */\r\nexport declare function getRefId(model: PureModel, key: string): IIdentifier | Array<IIdentifier>;\r\n/**\r\n * Set the id of the referenced model\r\n *\r\n * @export\r\n * @param {PureModel} model Source model\r\n * @param {string} key Referenced model property name\r\n * @param {IIdentifier} value The new value\r\n * @returns {void} Referenced model id\r\n */\r\nexport declare function setRefId(model: PureModel, key: string, value: IIdentifier | Array<IIdentifier>): void;\r\n"}}

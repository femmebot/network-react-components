{"code":"import { assignComputed, META_FIELD } from 'datx-utils';\r\nimport { FieldType } from '../../enums/FieldType';\r\nimport { ReferenceType } from '../../enums/ReferenceType';\r\nimport { ID_REQUIRED } from '../../errors';\r\nimport { storage } from '../../services/storage';\r\nimport { getField, getRef, updateField, updateRef } from './fields';\r\nimport { getModelMetaKey, getModelType, setModelMetaKey } from './utils';\r\nexport function initModelField(obj, key, defValue, type) {\r\n    if (type === void 0) { type = FieldType.DATA; }\r\n    var fields = getModelMetaKey(obj, 'fields');\r\n    if (type === FieldType.ID && key in obj) {\r\n        delete obj[key];\r\n    }\r\n    // Initialize the observable field to the default value\r\n    storage.setModelDataKey(obj, key, defValue);\r\n    if (fields.indexOf(key) === -1) {\r\n        fields.push(key);\r\n    }\r\n    assignComputed(obj, key, function () { return getField(obj, key); }, function (value) {\r\n        updateField(obj, key, value, type);\r\n    });\r\n}\r\n/**\r\n * Initialize a reference to other models\r\n *\r\n * @export\r\n * @param {PureModel} obj Model to which the reference should be added\r\n * @param {string} key Model property where the reference will be defined\r\n * @param {IReferenceOptions} options Reference options\r\n * @param {TRefValue} initialVal Initial reference value\r\n */\r\nexport function initModelRef(obj, key, options, initialVal) {\r\n    var refs = getModelMetaKey(obj, 'refs');\r\n    // Initialize the observable field to the given value\r\n    refs[key] = options;\r\n    var isArray = options.type === ReferenceType.TO_MANY;\r\n    storage.setModelDataKey(obj, key, isArray ? [] : undefined);\r\n    assignComputed(obj, key, function () { return getRef(obj, key); }, function (value) {\r\n        updateRef(obj, key, value);\r\n    });\r\n    if (!options.property && initialVal !== undefined) {\r\n        obj[key] = initialVal;\r\n    }\r\n}\r\nfunction prepareFields(data, meta, model) {\r\n    var staticModel = model.constructor;\r\n    var fields = meta.fields ? meta.fields.slice() : [];\r\n    var classRefs = storage.getModelClassReferences(staticModel);\r\n    var refs = Object.assign({}, classRefs, meta.refs);\r\n    var defaults = storage.getModelDefaults(staticModel);\r\n    Object.keys(data).concat(Object.keys(defaults))\r\n        .forEach(function (key) {\r\n        if (!(key in refs) && fields.indexOf(key) === -1) {\r\n            fields.push(key);\r\n        }\r\n    });\r\n    return { defaults: defaults, fields: fields, refs: refs };\r\n}\r\nfunction initModelData(model, data, meta, collection) {\r\n    var _a = prepareFields(data, meta, model), defaults = _a.defaults, fields = _a.fields, refs = _a.refs;\r\n    var staticModel = model.constructor;\r\n    var modelId = storage.getModelClassMetaKey(staticModel, 'id');\r\n    var modelType = storage.getModelClassMetaKey(staticModel, 'type');\r\n    fields.forEach(function (key) {\r\n        var type = FieldType.DATA;\r\n        var value = data[key];\r\n        if (value === undefined) {\r\n            value = defaults[key];\r\n        }\r\n        if (key === (modelId || 'id')) {\r\n            type = FieldType.ID;\r\n            value = meta.id;\r\n        }\r\n        else if (key === modelType) {\r\n            type = FieldType.TYPE;\r\n            value = meta.type;\r\n        }\r\n        initModelField(model, key, value, type);\r\n    });\r\n    if (modelId && !(modelId in fields)) {\r\n        initModelField(model, modelId, meta.id, FieldType.ID);\r\n    }\r\n    Object.keys(refs).forEach(function (key) {\r\n        var opts = refs[key];\r\n        var value = data[key] || defaults[key] || undefined;\r\n        var models = collection ? collection.add(value, getModelType(opts.model)) : value;\r\n        initModelRef(model, key, opts, models);\r\n    });\r\n}\r\nfunction initModelMeta(model, data, collection) {\r\n    var staticModel = model.constructor;\r\n    var modelId = storage.getModelClassMetaKey(staticModel, 'id') || 'id';\r\n    var modelType = storage.getModelClassMetaKey(staticModel, 'type');\r\n    var type = (modelType && data[modelType]) || getModelType(model);\r\n    var id = (modelId && data[modelId]);\r\n    if (!id) {\r\n        if (!staticModel.enableAutoId) {\r\n            throw new Error(ID_REQUIRED);\r\n        }\r\n        id = staticModel.getAutoId();\r\n        while (collection && collection.find(type, id)) {\r\n            id = staticModel.getAutoId();\r\n        }\r\n    }\r\n    var meta = {\r\n        fields: [],\r\n        id: id,\r\n        refs: {},\r\n        type: type,\r\n    };\r\n    var newMeta;\r\n    var toInit = { fields: [], refs: {} };\r\n    if (META_FIELD in data && data[META_FIELD]) {\r\n        var oldMeta = data[META_FIELD] || {};\r\n        toInit.fields = oldMeta.fields;\r\n        delete oldMeta.fields;\r\n        toInit.refs = oldMeta.refs;\r\n        delete oldMeta.refs;\r\n        newMeta = storage.setModelMeta(model, Object.assign(meta, oldMeta));\r\n        delete data[META_FIELD];\r\n    }\r\n    else {\r\n        newMeta = storage.setModelMeta(model, meta);\r\n    }\r\n    return Object.assign({}, newMeta, toInit);\r\n}\r\nexport function initModel(model, rawData, collection) {\r\n    var staticModel = model.constructor;\r\n    var data = Object.assign({}, staticModel.preprocess(rawData, collection));\r\n    setModelMetaKey(model, 'collection', collection);\r\n    var meta = initModelMeta(model, data, collection);\r\n    initModelData(model, data, meta, collection);\r\n}\r\n","dts":{"name":"/Users/darko/Projects/mobx/datx/packages/datx/helpers/model/init.d.ts","text":"import { IRawModel } from 'datx-utils';\r\nimport { FieldType } from '../../enums/FieldType';\r\nimport { IReferenceOptions } from '../../interfaces/IReferenceOptions';\r\nimport { TRefValue } from '../../interfaces/TRefValue';\r\nimport { PureCollection } from '../../PureCollection';\r\nimport { PureModel } from '../../PureModel';\r\nexport declare function initModelField<T extends PureModel>(obj: T, key: string, defValue: any, type?: FieldType): void;\r\n/**\r\n * Initialize a reference to other models\r\n *\r\n * @export\r\n * @param {PureModel} obj Model to which the reference should be added\r\n * @param {string} key Model property where the reference will be defined\r\n * @param {IReferenceOptions} options Reference options\r\n * @param {TRefValue} initialVal Initial reference value\r\n */\r\nexport declare function initModelRef(obj: PureModel, key: string, options: IReferenceOptions, initialVal: TRefValue): void;\r\nexport declare function initModel(model: PureModel, rawData: IRawModel, collection?: PureCollection): void;\r\n"}}

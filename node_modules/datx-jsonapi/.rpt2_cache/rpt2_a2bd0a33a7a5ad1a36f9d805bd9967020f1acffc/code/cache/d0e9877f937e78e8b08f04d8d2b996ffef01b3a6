{"map":"{\"version\":3,\"file\":\"model.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../src/helpers/model.ts\"],\"names\":[],\"mappings\":\"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\",\"sourcesContent\":[\"import {\\n  getModelCollection,\\n  getModelId,\\n  getModelMetaKey,\\n  getModelType,\\n  getRefId,\\n  IIdentifier,\\n  modelToJSON,\\n  PureModel,\\n  ReferenceType,\\n  setModelMetaKey,\\n} from 'datx';\\nimport {IDictionary, IRawModel, mapItems, META_FIELD} from 'datx-utils';\\nimport {isObservableArray} from 'mobx';\\n\\nimport {clearCacheByType} from '../cache';\\nimport {\\n  MODEL_LINKS_FIELD,\\n  MODEL_META_FIELD,\\n  MODEL_PERSISTED_FIELD,\\n  MODEL_PROP_FIELD,\\n  MODEL_QUEUE_FIELD,\\n  MODEL_REF_LINKS_FIELD,\\n  MODEL_REF_META_FIELD,\\n  MODEL_RELATED_FIELD,\\n} from '../consts';\\nimport {IJsonapiCollection} from '../interfaces/IJsonapiCollection';\\nimport {IJsonapiModel} from '../interfaces/IJsonapiModel';\\nimport {IRequestOptions} from '../interfaces/IRequestOptions';\\nimport {IDefinition, ILink, IRecord, IRelationship} from '../interfaces/JsonApi';\\nimport {config, create, fetchLink, handleResponse, remove, update} from '../NetworkUtils';\\nimport {Response} from '../Response';\\nimport {getValue} from './utils';\\n\\nexport function flattenModel(): null;\\nexport function flattenModel(data?: IRecord): IRawModel;\\nexport function flattenModel(data?: IRecord): IRawModel|null {\\n  if (!data) {\\n    return null;\\n  }\\n\\n  const rawData = {\\n    [META_FIELD]: {\\n      fields: Object.keys(data.attributes),\\n      id: data.id,\\n      [MODEL_LINKS_FIELD]: data.links,\\n      [MODEL_META_FIELD]: data.meta,\\n      [MODEL_PERSISTED_FIELD]: Boolean(data.id),\\n      refs: {},\\n      type: data.type,\\n    },\\n  };\\n\\n  if (data.relationships) {\\n    const refLinks = {};\\n    const refMeta = {};\\n    const refs = {};\\n    Object.keys(data.relationships).forEach((key) => {\\n      const ref = (data.relationships as IDictionary<IRelationship>)[key];\\n      if ('data' in ref && ref.data && (!(ref.data instanceof Array) || ref.data.length > 0)) {\\n        rawData[key] = mapItems(ref.data, (item: IDefinition) => item.id);\\n        refs[key] = {\\n          model: ref.data instanceof Array ? ref.data[0].type : ref.data.type,\\n          type: ref.data instanceof Array ? ReferenceType.TO_MANY : ReferenceType.TO_ONE,\\n        };\\n      }\\n      if ('links' in ref) {\\n        refLinks[key] = ref.links;\\n      }\\n      if ('meta' in ref) {\\n        refMeta[key] = ref.meta;\\n      }\\n    });\\n\\n    rawData[META_FIELD].refs = refs;\\n    rawData[META_FIELD][MODEL_REF_LINKS_FIELD] = refLinks;\\n    rawData[META_FIELD][MODEL_REF_META_FIELD] = refMeta;\\n  }\\n\\n  return Object.assign(rawData, data.attributes);\\n}\\n\\nexport function getModelMeta(model: PureModel): IDictionary {\\n  return getModelMetaKey(model, MODEL_META_FIELD);\\n}\\n\\nexport function getModelLinks(model: PureModel): IDictionary<ILink> {\\n  return getModelMetaKey(model, MODEL_LINKS_FIELD);\\n}\\n\\nexport async function fetchModelLink<T extends IJsonapiModel = IJsonapiModel>(\\n  model: PureModel,\\n  key: string,\\n  requestHeaders?: IDictionary<string>,\\n  options?: IRequestOptions,\\n): Promise<Response<T>> {\\n  const collection = getModelCollection(model);\\n  const links = getModelLinks(model);\\n  if (!(key in links)) {\\n    throw new Error(`Link ${key} doesn't exist on the model`);\\n  }\\n  const link = links[key];\\n  const responseObj = fetchLink<T>(link, collection as IJsonapiCollection, requestHeaders, options);\\n\\n  if (getModelMetaKey(model, MODEL_QUEUE_FIELD)) {\\n    return responseObj.then((response) => {\\n      const related = getModelMetaKey(model, MODEL_RELATED_FIELD);\\n      const prop = getModelMetaKey(model, MODEL_PROP_FIELD);\\n      const record = response.data;\\n      const recordType = record && getModelType(record);\\n      if (record && recordType !== getModelType(model) && recordType === getModelType(related)) {\\n        if (prop) {\\n          related[prop] = record;\\n\\n          return response;\\n        }\\n        setModelMetaKey(related, MODEL_PERSISTED_FIELD, true);\\n\\n        return response.replaceData(related);\\n      }\\n\\n      return response;\\n    });\\n  }\\n\\n  return responseObj;\\n}\\n\\nfunction getLink(model: PureModel, ref: string, key: string) {\\n  const collection = getModelCollection(model);\\n  if (!collection) {\\n    throw new Error('The model needs to be in a collection');\\n  }\\n  const links = getModelRefLinks(model);\\n  if (!(ref in links)) {\\n    throw new Error(`The reference ${ref} doesn't have any links`);\\n  }\\n  const refLinks = links[ref];\\n  if (!(key in refLinks)) {\\n    throw new Error(`Link ${key} doesn't exist on the model`);\\n  }\\n\\n  return refLinks[key];\\n}\\n\\nexport async function fetchModelRefLink<T extends IJsonapiModel = IJsonapiModel>(\\n  model: PureModel,\\n  ref: string,\\n  key: string,\\n  requestHeaders?: IDictionary<string>,\\n  options?: IRequestOptions,\\n): Promise<Response<T>> {\\n  const collection = getModelCollection(model);\\n  const link = getLink(model, ref, key);\\n\\n  return fetchLink<T>(link, collection as IJsonapiCollection, requestHeaders, options);\\n}\\n\\nexport function getModelRefLinks(model: PureModel): IDictionary<IDictionary<ILink>> {\\n  return getModelMetaKey(model, MODEL_REF_LINKS_FIELD);\\n}\\n\\nexport function getModelRefMeta(model: PureModel): IDictionary {\\n  return getModelMetaKey(model, MODEL_REF_META_FIELD);\\n}\\n\\nfunction isModelPersisted(model: PureModel): boolean {\\n  return getModelMetaKey(model, MODEL_PERSISTED_FIELD);\\n}\\n\\nfunction setModelPersisted(model: PureModel, status: boolean) {\\n  setModelMetaKey(model, MODEL_PERSISTED_FIELD, status);\\n}\\n\\nexport function modelToJsonApi(model: IJsonapiModel): IRecord {\\n  const staticModel = model.constructor as typeof PureModel;\\n  const attributes: IDictionary = modelToJSON(model);\\n\\n  const useAutogenerated: boolean = staticModel['useAutogeneratedIds'];\\n  const isPersisted = isModelPersisted(model);\\n\\n  const data: IRecord = {\\n    attributes,\\n    id: (isPersisted || useAutogenerated) ? getModelId(model) : undefined,\\n    type: getModelType(model) as string,\\n  };\\n\\n  const refs = getModelMetaKey(model, 'refs');\\n\\n  Object.keys(refs).forEach((key) => {\\n    data.relationships = data.relationships || {};\\n    const refIds = getRefId(model, key);\\n    let rel: IDefinition|Array<IDefinition>|undefined;\\n    if (refIds instanceof Array || isObservableArray(refIds)) {\\n      rel = (refIds as Array<IIdentifier>).map((id, index) => {\\n        const type = model[key][index] ? getModelType(model[key][index]) : refs[key].model;\\n\\n        return {id, type};\\n      });\\n    } else {\\n      const type: string = model[key] ? getModelType(model[key]) : refs[key].model;\\n      rel = refIds ? {id: refIds, type} : undefined;\\n    }\\n\\n    data.relationships[key] = {data: rel};\\n    delete data.attributes[key];\\n  });\\n\\n  delete data.attributes.id;\\n\\n  delete data.attributes[META_FIELD];\\n\\n  return data;\\n}\\n\\nfunction getModelEndpointUrl(model: PureModel): string {\\n  const staticModel = model.constructor;\\n  const links: IDictionary<ILink> = getModelLinks(model);\\n  if (links && links.self) {\\n    const self: ILink = links.self;\\n\\n    return typeof self === 'string' ? self : self.href;\\n  }\\n\\n  const url = getValue<string>(staticModel['endpoint']) || getModelType(model);\\n\\n  return isModelPersisted(model)\\n    ? `${config.baseUrl}${url}/${getModelId(model)}`\\n    : `${config.baseUrl}${url}`;\\n}\\n\\nexport function saveModel(model: IJsonapiModel, options?: IRequestOptions): Promise<IJsonapiModel> {\\n  const collection = getModelCollection(model) as IJsonapiCollection;\\n\\n  const data: IRecord = modelToJsonApi(model);\\n  const requestMethod = isModelPersisted(model) ? update : create;\\n  const url = getModelEndpointUrl(model);\\n\\n  return requestMethod(url, {data}, collection, options && options.headers)\\n    .then(handleResponse(model))\\n    .then((response) => {\\n      clearCacheByType(getModelType(model));\\n\\n      return response;\\n    });\\n}\\n\\nexport function removeModel<T extends IJsonapiModel>(model: T, options?: IRequestOptions): Promise<void> {\\n  const collection = getModelCollection(model) as IJsonapiCollection;\\n\\n  const isPersisted = isModelPersisted(model);\\n  const url = getModelEndpointUrl(model);\\n\\n  if (isPersisted) {\\n    return remove(url, collection, options && options.headers)\\n      .then((response: Response<T>) => {\\n        if (response.error) {\\n          throw response.error;\\n        }\\n\\n        setModelPersisted(model, false);\\n\\n        if (collection) {\\n          collection.remove(model);\\n        }\\n      });\\n  } else if (collection) {\\n    collection.remove(model);\\n  }\\n\\n  return Promise.resolve();\\n}\\n\\nexport function saveRelationship<T extends IJsonapiModel>(\\n  model: T,\\n  ref: string,\\n  options?: IRequestOptions,\\n): Promise<T> {\\n  const collection = getModelCollection(model) as IJsonapiCollection;\\n  const link = getLink(model, ref, 'self');\\n  const href: string = typeof link === 'object' ? link.href : link;\\n\\n  const ids = getRefId(model, ref);\\n  const type = getModelType(getModelMetaKey(model, 'refs')[ref].model);\\n  type ID = IDefinition|Array<IDefinition>;\\n  const data: ID = mapItems(ids, (id) => ({id, type})) as ID;\\n\\n  return update(href, {data}, collection, options && options.headers)\\n    .then(handleResponse(model, ref));\\n}\\n\"]}","code":"import * as tslib_1 from \"tslib\";\r\nimport { getModelCollection, getModelId, getModelMetaKey, getModelType, getRefId, modelToJSON, ReferenceType, setModelMetaKey, } from 'datx';\r\nimport { mapItems, META_FIELD } from 'datx-utils';\r\nimport { isObservableArray } from 'mobx';\r\nimport { clearCacheByType } from '../cache';\r\nimport { MODEL_LINKS_FIELD, MODEL_META_FIELD, MODEL_PERSISTED_FIELD, MODEL_PROP_FIELD, MODEL_QUEUE_FIELD, MODEL_REF_LINKS_FIELD, MODEL_REF_META_FIELD, MODEL_RELATED_FIELD, } from '../consts';\r\nimport { config, create, fetchLink, handleResponse, remove, update } from '../NetworkUtils';\r\nimport { getValue } from './utils';\r\nexport function flattenModel(data) {\r\n    if (!data) {\r\n        return null;\r\n    }\r\n    var rawData = (_a = {},\r\n        _a[META_FIELD] = (_b = {\r\n                fields: Object.keys(data.attributes),\r\n                id: data.id\r\n            },\r\n            _b[MODEL_LINKS_FIELD] = data.links,\r\n            _b[MODEL_META_FIELD] = data.meta,\r\n            _b[MODEL_PERSISTED_FIELD] = Boolean(data.id),\r\n            _b.refs = {},\r\n            _b.type = data.type,\r\n            _b),\r\n        _a);\r\n    if (data.relationships) {\r\n        var refLinks_1 = {};\r\n        var refMeta_1 = {};\r\n        var refs_1 = {};\r\n        Object.keys(data.relationships).forEach(function (key) {\r\n            var ref = data.relationships[key];\r\n            if ('data' in ref && ref.data && (!(ref.data instanceof Array) || ref.data.length > 0)) {\r\n                rawData[key] = mapItems(ref.data, function (item) { return item.id; });\r\n                refs_1[key] = {\r\n                    model: ref.data instanceof Array ? ref.data[0].type : ref.data.type,\r\n                    type: ref.data instanceof Array ? ReferenceType.TO_MANY : ReferenceType.TO_ONE,\r\n                };\r\n            }\r\n            if ('links' in ref) {\r\n                refLinks_1[key] = ref.links;\r\n            }\r\n            if ('meta' in ref) {\r\n                refMeta_1[key] = ref.meta;\r\n            }\r\n        });\r\n        rawData[META_FIELD].refs = refs_1;\r\n        rawData[META_FIELD][MODEL_REF_LINKS_FIELD] = refLinks_1;\r\n        rawData[META_FIELD][MODEL_REF_META_FIELD] = refMeta_1;\r\n    }\r\n    return Object.assign(rawData, data.attributes);\r\n    var _a, _b;\r\n}\r\nexport function getModelMeta(model) {\r\n    return getModelMetaKey(model, MODEL_META_FIELD);\r\n}\r\nexport function getModelLinks(model) {\r\n    return getModelMetaKey(model, MODEL_LINKS_FIELD);\r\n}\r\nexport function fetchModelLink(model, key, requestHeaders, options) {\r\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n        var collection, links, link, responseObj;\r\n        return tslib_1.__generator(this, function (_a) {\r\n            collection = getModelCollection(model);\r\n            links = getModelLinks(model);\r\n            if (!(key in links)) {\r\n                throw new Error(\"Link \" + key + \" doesn't exist on the model\");\r\n            }\r\n            link = links[key];\r\n            responseObj = fetchLink(link, collection, requestHeaders, options);\r\n            if (getModelMetaKey(model, MODEL_QUEUE_FIELD)) {\r\n                return [2 /*return*/, responseObj.then(function (response) {\r\n                        var related = getModelMetaKey(model, MODEL_RELATED_FIELD);\r\n                        var prop = getModelMetaKey(model, MODEL_PROP_FIELD);\r\n                        var record = response.data;\r\n                        var recordType = record && getModelType(record);\r\n                        if (record && recordType !== getModelType(model) && recordType === getModelType(related)) {\r\n                            if (prop) {\r\n                                related[prop] = record;\r\n                                return response;\r\n                            }\r\n                            setModelMetaKey(related, MODEL_PERSISTED_FIELD, true);\r\n                            return response.replaceData(related);\r\n                        }\r\n                        return response;\r\n                    })];\r\n            }\r\n            return [2 /*return*/, responseObj];\r\n        });\r\n    });\r\n}\r\nfunction getLink(model, ref, key) {\r\n    var collection = getModelCollection(model);\r\n    if (!collection) {\r\n        throw new Error('The model needs to be in a collection');\r\n    }\r\n    var links = getModelRefLinks(model);\r\n    if (!(ref in links)) {\r\n        throw new Error(\"The reference \" + ref + \" doesn't have any links\");\r\n    }\r\n    var refLinks = links[ref];\r\n    if (!(key in refLinks)) {\r\n        throw new Error(\"Link \" + key + \" doesn't exist on the model\");\r\n    }\r\n    return refLinks[key];\r\n}\r\nexport function fetchModelRefLink(model, ref, key, requestHeaders, options) {\r\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n        var collection, link;\r\n        return tslib_1.__generator(this, function (_a) {\r\n            collection = getModelCollection(model);\r\n            link = getLink(model, ref, key);\r\n            return [2 /*return*/, fetchLink(link, collection, requestHeaders, options)];\r\n        });\r\n    });\r\n}\r\nexport function getModelRefLinks(model) {\r\n    return getModelMetaKey(model, MODEL_REF_LINKS_FIELD);\r\n}\r\nexport function getModelRefMeta(model) {\r\n    return getModelMetaKey(model, MODEL_REF_META_FIELD);\r\n}\r\nfunction isModelPersisted(model) {\r\n    return getModelMetaKey(model, MODEL_PERSISTED_FIELD);\r\n}\r\nfunction setModelPersisted(model, status) {\r\n    setModelMetaKey(model, MODEL_PERSISTED_FIELD, status);\r\n}\r\nexport function modelToJsonApi(model) {\r\n    var staticModel = model.constructor;\r\n    var attributes = modelToJSON(model);\r\n    var useAutogenerated = staticModel['useAutogeneratedIds'];\r\n    var isPersisted = isModelPersisted(model);\r\n    var data = {\r\n        attributes: attributes,\r\n        id: (isPersisted || useAutogenerated) ? getModelId(model) : undefined,\r\n        type: getModelType(model),\r\n    };\r\n    var refs = getModelMetaKey(model, 'refs');\r\n    Object.keys(refs).forEach(function (key) {\r\n        data.relationships = data.relationships || {};\r\n        var refIds = getRefId(model, key);\r\n        var rel;\r\n        if (refIds instanceof Array || isObservableArray(refIds)) {\r\n            rel = refIds.map(function (id, index) {\r\n                var type = model[key][index] ? getModelType(model[key][index]) : refs[key].model;\r\n                return { id: id, type: type };\r\n            });\r\n        }\r\n        else {\r\n            var type = model[key] ? getModelType(model[key]) : refs[key].model;\r\n            rel = refIds ? { id: refIds, type: type } : undefined;\r\n        }\r\n        data.relationships[key] = { data: rel };\r\n        delete data.attributes[key];\r\n    });\r\n    delete data.attributes.id;\r\n    delete data.attributes[META_FIELD];\r\n    return data;\r\n}\r\nfunction getModelEndpointUrl(model) {\r\n    var staticModel = model.constructor;\r\n    var links = getModelLinks(model);\r\n    if (links && links.self) {\r\n        var self = links.self;\r\n        return typeof self === 'string' ? self : self.href;\r\n    }\r\n    var url = getValue(staticModel['endpoint']) || getModelType(model);\r\n    return isModelPersisted(model)\r\n        ? \"\" + config.baseUrl + url + \"/\" + getModelId(model)\r\n        : \"\" + config.baseUrl + url;\r\n}\r\nexport function saveModel(model, options) {\r\n    var collection = getModelCollection(model);\r\n    var data = modelToJsonApi(model);\r\n    var requestMethod = isModelPersisted(model) ? update : create;\r\n    var url = getModelEndpointUrl(model);\r\n    return requestMethod(url, { data: data }, collection, options && options.headers)\r\n        .then(handleResponse(model))\r\n        .then(function (response) {\r\n        clearCacheByType(getModelType(model));\r\n        return response;\r\n    });\r\n}\r\nexport function removeModel(model, options) {\r\n    var collection = getModelCollection(model);\r\n    var isPersisted = isModelPersisted(model);\r\n    var url = getModelEndpointUrl(model);\r\n    if (isPersisted) {\r\n        return remove(url, collection, options && options.headers)\r\n            .then(function (response) {\r\n            if (response.error) {\r\n                throw response.error;\r\n            }\r\n            setModelPersisted(model, false);\r\n            if (collection) {\r\n                collection.remove(model);\r\n            }\r\n        });\r\n    }\r\n    else if (collection) {\r\n        collection.remove(model);\r\n    }\r\n    return Promise.resolve();\r\n}\r\nexport function saveRelationship(model, ref, options) {\r\n    var collection = getModelCollection(model);\r\n    var link = getLink(model, ref, 'self');\r\n    var href = typeof link === 'object' ? link.href : link;\r\n    var ids = getRefId(model, ref);\r\n    var type = getModelType(getModelMetaKey(model, 'refs')[ref].model);\r\n    var data = mapItems(ids, function (id) { return ({ id: id, type: type }); });\r\n    return update(href, { data: data }, collection, options && options.headers)\r\n        .then(handleResponse(model, ref));\r\n}\r\n//# sourceMappingURL=model.js.map","dts":{"name":"/Users/darko/Projects/mobx/datx/packages/datx-jsonapi/helpers/model.d.ts","text":"import { PureModel } from 'datx';\r\nimport { IDictionary, IRawModel } from 'datx-utils';\r\nimport { IJsonapiModel } from '../interfaces/IJsonapiModel';\r\nimport { IRequestOptions } from '../interfaces/IRequestOptions';\r\nimport { ILink, IRecord } from '../interfaces/JsonApi';\r\nimport { Response } from '../Response';\r\nexport declare function flattenModel(): null;\r\nexport declare function flattenModel(data?: IRecord): IRawModel;\r\nexport declare function getModelMeta(model: PureModel): IDictionary;\r\nexport declare function getModelLinks(model: PureModel): IDictionary<ILink>;\r\nexport declare function fetchModelLink<T extends IJsonapiModel = IJsonapiModel>(model: PureModel, key: string, requestHeaders?: IDictionary<string>, options?: IRequestOptions): Promise<Response<T>>;\r\nexport declare function fetchModelRefLink<T extends IJsonapiModel = IJsonapiModel>(model: PureModel, ref: string, key: string, requestHeaders?: IDictionary<string>, options?: IRequestOptions): Promise<Response<T>>;\r\nexport declare function getModelRefLinks(model: PureModel): IDictionary<IDictionary<ILink>>;\r\nexport declare function getModelRefMeta(model: PureModel): IDictionary;\r\nexport declare function modelToJsonApi(model: IJsonapiModel): IRecord;\r\nexport declare function saveModel(model: IJsonapiModel, options?: IRequestOptions): Promise<IJsonapiModel>;\r\nexport declare function removeModel<T extends IJsonapiModel>(model: T, options?: IRequestOptions): Promise<void>;\r\nexport declare function saveRelationship<T extends IJsonapiModel>(model: T, ref: string, options?: IRequestOptions): Promise<T>;\r\n"}}

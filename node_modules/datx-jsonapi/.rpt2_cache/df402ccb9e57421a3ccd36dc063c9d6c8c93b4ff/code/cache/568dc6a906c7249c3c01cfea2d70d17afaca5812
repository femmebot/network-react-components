{"code":"import * as tslib_1 from \"tslib\";\r\nimport { getModelId, getModelType, modelToJSON, updateModel, updateModelId } from 'datx';\r\nimport { assignComputed } from 'datx-utils';\r\nimport { action } from 'mobx';\r\nimport { GenericModel } from './GenericModel';\r\nimport { flattenModel } from './helpers/model';\r\nimport { fetchLink } from './NetworkUtils';\r\nvar Response = /** @class */ (function () {\r\n    function Response(response, collection, options, overrideData, views) {\r\n        var _this = this;\r\n        /**\r\n         * API response data (synced with the store)\r\n         *\r\n         * @type {(PureModel|Array<PureModel>)}\r\n         * @memberOf Response\r\n         */\r\n        this.data = null;\r\n        this.views = [];\r\n        /**\r\n         * Cache used for the link requests\r\n         *\r\n         * @private\r\n         * @type {IDictionary<Promise<Response>>}\r\n         * @memberOf Response\r\n         */\r\n        this.__cache = {};\r\n        this.__collection = collection;\r\n        this.__options = options;\r\n        this.__response = response;\r\n        this.status = response.status;\r\n        if (views) {\r\n            this.views = views;\r\n        }\r\n        if (collection) {\r\n            this.data = overrideData ? collection.add(overrideData) : collection.sync(response.data);\r\n        }\r\n        else if (response.data) {\r\n            // The case when a record is not in a store and save/remove are used\r\n            var resp = response.data;\r\n            if (resp.data) {\r\n                if (resp.data instanceof Array) {\r\n                    throw new Error('A save/remove operation should not return an array of results');\r\n                }\r\n                this.data = overrideData || new GenericModel(flattenModel(resp.data));\r\n            }\r\n        }\r\n        this.views.forEach(function (view) {\r\n            if (_this.data) {\r\n                view.add(_this.data);\r\n            }\r\n        });\r\n        this.meta = (response.data && response.data.meta) || {};\r\n        this.links = (response.data && response.data.links) || {};\r\n        this.jsonapi = (response.data && response.data.jsonapi) || {};\r\n        this.headers = response.headers;\r\n        this.requestHeaders = response.requestHeaders;\r\n        this.error = (response.data && response.data.errors) || response.error;\r\n        var linkGetter = {};\r\n        if (this.links) {\r\n            Object.keys(this.links).forEach(function (link) {\r\n                assignComputed(_this, link, function () { return _this.__fetchLink(link); });\r\n            });\r\n        }\r\n        Object.freeze(this);\r\n        if (this.error) {\r\n            throw this;\r\n        }\r\n    }\r\n    /**\r\n     * Replace the response record with a different record. Used to replace a record while keeping the same reference\r\n     *\r\n     * @param {PureModel} data New data\r\n     * @returns {Response}\r\n     *\r\n     * @memberOf Response\r\n     */\r\n    Response.prototype.replaceData = function (data) {\r\n        var record = this.data;\r\n        if (record === data) {\r\n            return this;\r\n        }\r\n        var oldId = getModelId(data);\r\n        var newId = getModelId(record);\r\n        var type = getModelType(record);\r\n        var viewIndexes = this.views.map(function (view) { return view.list.indexOf(record); });\r\n        if (this.__collection) {\r\n            this.__collection.remove(record);\r\n            this.__collection.add(data);\r\n        }\r\n        updateModel(data, modelToJSON(record));\r\n        updateModelId(data, newId);\r\n        this.views.forEach(function (view, index) {\r\n            if (viewIndexes[index] !== -1) {\r\n                view.list[viewIndexes[index]] = data;\r\n            }\r\n        });\r\n        return new Response(this.__response, this.__collection, this.__options, data);\r\n    };\r\n    /**\r\n     * Function called when a link is being fetched. The returned value is cached\r\n     *\r\n     * @private\r\n     * @param {any} name Link name\r\n     * @returns Promise that resolves with a Response object\r\n     *\r\n     * @memberOf Response\r\n     */\r\n    Response.prototype.__fetchLink = function (name) {\r\n        if (!this.__cache[name]) {\r\n            var link = (this.links && name in this.links) ? this.links[name] : null;\r\n            if (link) {\r\n                this.__cache[name] = fetchLink(link, this.__collection, this.requestHeaders, this.__options, this.views);\r\n            }\r\n        }\r\n        return this.__cache[name];\r\n    };\r\n    tslib_1.__decorate([\r\n        action\r\n    ], Response.prototype, \"replaceData\", null);\r\n    return Response;\r\n}());\r\nexport { Response };\r\n","dts":{"name":"/Users/darko/Projects/mobx/datx/packages/datx-jsonapi/Response.d.ts","text":"import { View } from 'datx';\r\nimport { IDictionary } from 'datx-utils';\r\nimport { IHeaders } from './interfaces/IHeaders';\r\nimport { IJsonapiModel } from './interfaces/IJsonapiModel';\r\nimport { IRawResponse } from './interfaces/IRawResponse';\r\nimport { IRequestOptions } from './interfaces/IRequestOptions';\r\nimport { IResponseHeaders } from './interfaces/IResponseHeaders';\r\nimport { IError, IJsonApiObject, ILink } from './interfaces/JsonApi';\r\nimport { IJsonapiCollection } from './interfaces/IJsonapiCollection';\r\nexport declare class Response<T extends IJsonapiModel> {\r\n    /**\r\n     * API response data (synced with the store)\r\n     *\r\n     * @type {(PureModel|Array<PureModel>)}\r\n     * @memberOf Response\r\n     */\r\n    data: T | Array<T> | null;\r\n    /**\r\n     * API response metadata\r\n     *\r\n     * @type {object}\r\n     * @memberOf Response\r\n     */\r\n    meta?: object;\r\n    /**\r\n     * API response links\r\n     *\r\n     * @type {object}\r\n     * @memberOf Response\r\n     */\r\n    links?: IDictionary<ILink>;\r\n    /**\r\n     * The JSON API object returned by the server\r\n     *\r\n     * @type {JsonApi.IJsonApiObject}\r\n     * @memberOf Response\r\n     */\r\n    jsonapi?: IJsonApiObject;\r\n    /**\r\n     * Headers received from the API call\r\n     *\r\n     * @type {IResponseHeaders}\r\n     * @memberOf Response\r\n     */\r\n    headers?: IResponseHeaders;\r\n    /**\r\n     * Headers sent to the server\r\n     *\r\n     * @type {IHeaders}\r\n     * @memberOf Response\r\n     */\r\n    requestHeaders?: IHeaders;\r\n    /**\r\n     * Request error\r\n     *\r\n     * @type {(Array<JsonApi.IError>|Error)}\r\n     * @memberOf Response\r\n     */\r\n    error?: Array<IError> | Error;\r\n    /**\r\n     * First data page\r\n     *\r\n     * @type {Promise<Response>}\r\n     * @memberOf Response\r\n     */\r\n    first?: Promise<Response<T>>;\r\n    /**\r\n     * Previous data page\r\n     *\r\n     * @type {Promise<Response>}\r\n     * @memberOf Response\r\n     */\r\n    prev?: Promise<Response<T>>;\r\n    /**\r\n     * Next data page\r\n     *\r\n     * @type {Promise<Response>}\r\n     * @memberOf Response\r\n     */\r\n    next?: Promise<Response<T>>;\r\n    /**\r\n     * Last data page\r\n     *\r\n     * @type {Promise<Response>}\r\n     * @memberOf Response\r\n     */\r\n    last?: Promise<Response<T>>;\r\n    /**\r\n     * Received HTTP status\r\n     *\r\n     * @type {number}\r\n     * @memberOf Response\r\n     */\r\n    status?: number;\r\n    views: Array<View>;\r\n    /**\r\n     * Related Store\r\n     *\r\n     * @private\r\n     * @type {IJsonapiCollection}\r\n     * @memberOf Response\r\n     */\r\n    private __collection?;\r\n    /**\r\n     * Server options\r\n     *\r\n     * @private\r\n     * @type {IRequestOptions}\r\n     * @memberOf Response\r\n     */\r\n    private __options?;\r\n    /**\r\n     * Original server response\r\n     *\r\n     * @private\r\n     * @type {IRawResponse}\r\n     * @memberOf Response\r\n     */\r\n    private __response;\r\n    /**\r\n     * Cache used for the link requests\r\n     *\r\n     * @private\r\n     * @type {IDictionary<Promise<Response>>}\r\n     * @memberOf Response\r\n     */\r\n    private __cache;\r\n    constructor(response: IRawResponse, collection?: IJsonapiCollection, options?: IRequestOptions, overrideData?: T | Array<T>, views?: Array<View>);\r\n    /**\r\n     * Replace the response record with a different record. Used to replace a record while keeping the same reference\r\n     *\r\n     * @param {PureModel} data New data\r\n     * @returns {Response}\r\n     *\r\n     * @memberOf Response\r\n     */\r\n    replaceData(data: T): Response<T>;\r\n    /**\r\n     * Function called when a link is being fetched. The returned value is cached\r\n     *\r\n     * @private\r\n     * @param {any} name Link name\r\n     * @returns Promise that resolves with a Response object\r\n     *\r\n     * @memberOf Response\r\n     */\r\n    private __fetchLink(name);\r\n}\r\n"}}

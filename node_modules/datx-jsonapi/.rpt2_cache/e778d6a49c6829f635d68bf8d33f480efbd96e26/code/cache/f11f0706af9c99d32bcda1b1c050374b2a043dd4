{"code":"import { getModelType } from 'datx';\r\nvar cacheStorage = [];\r\nexport function saveCache(url, response, modelType) {\r\n    if ('data' in response && (!('error' in response) || !response.error) && response.data) {\r\n        // The type might need to be 100% correct - used only to clear the cache\r\n        var type = modelType || getModelType(response.data instanceof Array ? response.data[0] : response.data);\r\n        cacheStorage.push({ response: response, time: new Date(), type: type, url: url });\r\n    }\r\n}\r\nexport function getCache(url) {\r\n    return cacheStorage.find(function (item) { return item.url === url; });\r\n}\r\nexport function clearAllCache() {\r\n    cacheStorage.length = 0;\r\n}\r\nexport function clearCacheByType(type) {\r\n    cacheStorage = cacheStorage.filter(function (item) { return item.type !== type; });\r\n}\r\n//# sourceMappingURL=cache.js.map","map":"{\"version\":3,\"file\":\"cache.js\",\"sourceRoot\":\"\",\"sources\":[\"../../src/cache.ts\"],\"names\":[],\"mappings\":\"AAAA,OAAO,EAAC,YAAY,EAAQ,MAAM,MAAM,CAAC;AAazC,IAAI,YAAY,GAAkB,EAAE,CAAC;AAErC,MAAM,oBAAoB,GAAW,EAAE,QAAiC,EAAE,SAAkB;IAC1F,IAAI,MAAM,IAAI,QAAQ,IAAI,CAAC,CAAC,CAAC,OAAO,IAAI,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,QAAQ,CAAC,IAAI,EAAE;QACtF,wEAAwE;QACxE,IAAM,IAAI,GAAG,SAAS,IAAI,YAAY,CAAC,QAAQ,CAAC,IAAI,YAAY,KAAK,CAAC,CAAC,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;QAC1G,YAAY,CAAC,IAAI,CAAC,EAAC,QAAQ,UAAA,EAAE,IAAI,EAAE,IAAI,IAAI,EAAE,EAAE,IAAI,MAAA,EAAE,GAAG,KAAA,EAAC,CAAC,CAAC;KAC5D;AACH,CAAC;AAED,MAAM,mBAAmB,GAAW;IAClC,OAAO,YAAY,CAAC,IAAI,CAAC,UAAC,IAAI,IAAK,OAAA,IAAI,CAAC,GAAG,KAAK,GAAG,EAAhB,CAAgB,CAAC,CAAC;AACvD,CAAC;AAED,MAAM;IACJ,YAAY,CAAC,MAAM,GAAG,CAAC,CAAC;AAC1B,CAAC;AAED,MAAM,2BAA2B,IAAW;IAC1C,YAAY,GAAG,YAAY,CAAC,MAAM,CAAC,UAAC,IAAI,IAAK,OAAA,IAAI,CAAC,IAAI,KAAK,IAAI,EAAlB,CAAkB,CAAC,CAAC;AACnE,CAAC\",\"sourcesContent\":[\"import {getModelType, IType} from 'datx';\\nimport {IDictionary} from 'datx-utils';\\n\\nimport {IJsonapiModel} from './interfaces/IJsonapiModel';\\nimport {Response} from './Response';\\n\\nexport interface ICache {\\n  response: Response<IJsonapiModel>;\\n  time: Date;\\n  type: IType;\\n  url: string;\\n}\\n\\nlet cacheStorage: Array<ICache> = [];\\n\\nexport function saveCache(url: string, response: Response<IJsonapiModel>, modelType?: string) {\\n  if ('data' in response && (!('error' in response) || !response.error) && response.data) {\\n    // The type might need to be 100% correct - used only to clear the cache\\n    const type = modelType || getModelType(response.data instanceof Array ? response.data[0] : response.data);\\n    cacheStorage.push({response, time: new Date(), type, url});\\n  }\\n}\\n\\nexport function getCache(url: string): ICache|undefined {\\n  return cacheStorage.find((item) => item.url === url);\\n}\\n\\nexport function clearAllCache() {\\n  cacheStorage.length = 0;\\n}\\n\\nexport function clearCacheByType(type: IType) {\\n  cacheStorage = cacheStorage.filter((item) => item.type !== type);\\n}\\n\"]}","dts":{"name":"/Users/darko/Projects/mobx/datx/packages/datx-jsonapi/cache.d.ts","text":"import { IType } from 'datx';\r\nimport { IJsonapiModel } from './interfaces/IJsonapiModel';\r\nimport { Response } from './Response';\r\nexport interface ICache {\r\n    response: Response<IJsonapiModel>;\r\n    time: Date;\r\n    type: IType;\r\n    url: string;\r\n}\r\nexport declare function saveCache(url: string, response: Response<IJsonapiModel>, modelType?: string): void;\r\nexport declare function getCache(url: string): ICache | undefined;\r\nexport declare function clearAllCache(): void;\r\nexport declare function clearCacheByType(type: IType): void;\r\n"}}

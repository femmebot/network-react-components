{"code":"import * as tslib_1 from \"tslib\";\r\nimport { setModelMetaKey } from 'datx';\r\nimport { getCache, saveCache } from './cache';\r\nimport { MODEL_PERSISTED_FIELD, MODEL_PROP_FIELD, MODEL_QUEUE_FIELD, MODEL_RELATED_FIELD } from './consts';\r\nimport { ParamArrayType } from './enums/ParamArrayType';\r\nimport { isBrowser } from './helpers/utils';\r\nimport { Response as LibResponse } from './Response';\r\nexport var config = {\r\n    // Base URL for all API calls\r\n    baseUrl: '/',\r\n    // Enable caching by default in the browser\r\n    cache: isBrowser,\r\n    // Default options that will be passed to the fetch function\r\n    defaultFetchOptions: {\r\n        headers: {\r\n            'content-type': 'application/vnd.api+json',\r\n        },\r\n    },\r\n    // Reference of the fetch method that should be used\r\n    fetchReference: isBrowser && 'fetch' in window && window.fetch.bind(window),\r\n    // Determines how will the request param arrays be stringified\r\n    paramArrayType: ParamArrayType.COMMA_SEPARATED,\r\n    /**\r\n     * Base implementation of the fetch function (can be overridden)\r\n     *\r\n     * @param {string} method API call method\r\n     * @param {string} url API call URL\r\n     * @param {object} [body] API call body\r\n     * @param {IHeaders} [requestHeaders] Headers that will be sent\r\n     * @returns {Promise<IRawResponse>} Resolves with a raw response object\r\n     */\r\n    baseFetch: function (method, url, body, requestHeaders) {\r\n        var _this = this;\r\n        var data;\r\n        var status;\r\n        var headers;\r\n        var request = Promise.resolve();\r\n        var uppercaseMethod = method.toUpperCase();\r\n        var isBodySupported = uppercaseMethod !== 'GET' && uppercaseMethod !== 'HEAD';\r\n        return request\r\n            .then(function () {\r\n            var defaultHeaders = config.defaultFetchOptions.headers || {};\r\n            var reqHeaders = Object.assign({}, defaultHeaders, requestHeaders);\r\n            var options = Object.assign({}, config.defaultFetchOptions, {\r\n                body: isBodySupported && JSON.stringify(body) || undefined,\r\n                headers: reqHeaders,\r\n                method: method,\r\n            });\r\n            return _this.fetchReference(url, options);\r\n        })\r\n            .then(function (response) {\r\n            status = response.status;\r\n            headers = response.headers;\r\n            return response.json();\r\n        })\r\n            .catch(function (error) {\r\n            if (status === 204) {\r\n                return null;\r\n            }\r\n            throw error;\r\n        })\r\n            .then(function (responseData) {\r\n            data = responseData;\r\n            if (status >= 400) {\r\n                throw {\r\n                    message: \"Invalid HTTP status: \" + status,\r\n                    status: status,\r\n                };\r\n            }\r\n            return { data: data, headers: headers, requestHeaders: requestHeaders, status: status };\r\n        })\r\n            .catch(function (error) {\r\n            return _this.onError({ data: data, error: error, headers: headers, requestHeaders: requestHeaders, status: status });\r\n        });\r\n    },\r\n    onError: function (resp) {\r\n        return resp;\r\n    },\r\n    transformRequest: function (options) {\r\n        return options;\r\n    },\r\n    transformResponse: function (response) {\r\n        return response;\r\n    },\r\n};\r\n/**\r\n * Base implementation of the stateful fetch function (can be overridden)\r\n *\r\n * @param {ICollectionFetchOpts} reqOptions API request options\r\n * @returns {Promise<Response>} Resolves with a response object\r\n */\r\nfunction collectionFetch(reqOptions) {\r\n    var _a = config.transformRequest(reqOptions), url = _a.url, options = _a.options, data = _a.data, _b = _a.method, method = _b === void 0 ? 'GET' : _b, collection = _a.collection, views = _a.views;\r\n    var staticCollection = collection && collection.constructor;\r\n    var collectionCache = staticCollection && staticCollection.cache;\r\n    var isCacheSupported = method.toUpperCase() === 'GET';\r\n    var skipCache = reqOptions.options && reqOptions.options.skipCache;\r\n    if (config.cache && isCacheSupported && collectionCache && !skipCache) {\r\n        var cache = getCache(url);\r\n        if (cache) {\r\n            return Promise.resolve(cache.response);\r\n        }\r\n    }\r\n    return config.baseFetch(method, url, data, options && options.headers)\r\n        .then(function (response) {\r\n        var collectionResponse = Object.assign(response, { collection: collection });\r\n        var resp = new LibResponse(config.transformResponse(collectionResponse), collection, options, undefined, views);\r\n        if (config.cache && isCacheSupported) {\r\n            saveCache(url, resp);\r\n        }\r\n        return resp;\r\n    });\r\n}\r\nexport function fetch(options) {\r\n    return collectionFetch(options);\r\n}\r\n/**\r\n * API call used to get data from the server\r\n *\r\n * @export\r\n * @param {IJsonapiCollection} collection Related collection\r\n * @param {string} url API call URL\r\n * @param {IHeaders} [headers] Headers to be sent\r\n * @param {IRequestOptions} [options] Server options\r\n * @param {Array<View>} [views] Request view\r\n * @returns {Promise<Response>} Resolves with a Response object\r\n */\r\nexport function read(url, collection, headers, options, views) {\r\n    return collectionFetch({\r\n        collection: collection,\r\n        data: undefined,\r\n        method: 'GET',\r\n        options: tslib_1.__assign({}, options, { headers: headers }),\r\n        url: url,\r\n        views: views,\r\n    });\r\n}\r\n/**\r\n * API call used to create data on the server\r\n *\r\n * @export\r\n * @param {IJsonapiCollection} collection Related collection\r\n * @param {string} url API call URL\r\n * @param {object} [data] Request body\r\n * @param {IHeaders} [headers] Headers to be sent\r\n * @param {IRequestOptions} [options] Server options\r\n * @param {Array<View>} [views] Request view\r\n * @returns {Promise<Response>} Resolves with a Response object\r\n */\r\nexport function create(url, data, collection, headers, options, views) {\r\n    return collectionFetch({\r\n        collection: collection,\r\n        data: data,\r\n        method: 'POST',\r\n        options: tslib_1.__assign({}, options, { headers: headers }),\r\n        url: url,\r\n        views: views,\r\n    });\r\n}\r\n/**\r\n * API call used to update data on the server\r\n *\r\n * @export\r\n * @param {IJsonapiCollection} collection Related collection\r\n * @param {string} url API call URL\r\n * @param {object} [data] Request body\r\n * @param {IHeaders} [headers] Headers to be sent\r\n * @param {IRequestOptions} [options] Server options\r\n * @param {Array<View>} [views] Request view\r\n * @returns {Promise<Response>} Resolves with a Response object\r\n */\r\nexport function update(url, data, collection, headers, options, views) {\r\n    return collectionFetch({\r\n        collection: collection,\r\n        data: data,\r\n        method: 'PATCH',\r\n        options: tslib_1.__assign({}, options, { headers: headers }),\r\n        url: url,\r\n        views: views,\r\n    });\r\n}\r\n/**\r\n * API call used to remove data from the server\r\n *\r\n * @export\r\n * @param {IJsonapiCollection} collection Related collection\r\n * @param {string} url API call URL\r\n * @param {IHeaders} [headers] Headers to be sent\r\n * @param {IRequestOptions} [options] Server options\r\n * @param {Array<View>} [views] Request view\r\n * @returns {Promise<Response>} Resolves with a Response object\r\n */\r\nexport function remove(url, collection, headers, options, views) {\r\n    return collectionFetch({\r\n        collection: collection,\r\n        data: undefined,\r\n        method: 'DELETE',\r\n        options: tslib_1.__assign({}, options, { headers: headers }),\r\n        url: url,\r\n        views: views,\r\n    });\r\n}\r\n/**\r\n * Fetch a link from the server\r\n *\r\n * @export\r\n * @param {JsonApi.ILink} link Link URL or a link object\r\n * @param {IJsonapiCollection} collection Store that will be used to save the response\r\n * @param {IDictionary<string>} [requestHeaders] Request headers\r\n * @param {IRequestOptions} [options] Server options\r\n * @param {Array<View>} [views] Request view\r\n * @returns {Promise<LibResponse>} Response promise\r\n */\r\nexport function fetchLink(link, collection, requestHeaders, options, views) {\r\n    if (link) {\r\n        var href = typeof link === 'object' ? link.href : link;\r\n        if (href) {\r\n            return read(href, collection, requestHeaders, options, views);\r\n        }\r\n    }\r\n    return Promise.resolve(new LibResponse({ data: undefined }, collection));\r\n}\r\nexport function handleResponse(record, prop) {\r\n    return function (response) {\r\n        if (response.error) {\r\n            throw response.error;\r\n        }\r\n        if (response.status === 204) {\r\n            setModelMetaKey(record, MODEL_PERSISTED_FIELD, true);\r\n            return record;\r\n        }\r\n        else if (response.status === 202) {\r\n            var responseRecord = response.data;\r\n            setModelMetaKey(responseRecord, MODEL_PROP_FIELD, prop);\r\n            setModelMetaKey(responseRecord, MODEL_QUEUE_FIELD, true);\r\n            setModelMetaKey(responseRecord, MODEL_RELATED_FIELD, record);\r\n            return responseRecord;\r\n        }\r\n        else {\r\n            setModelMetaKey(record, MODEL_PERSISTED_FIELD, true);\r\n            return response.replaceData(record).data;\r\n        }\r\n    };\r\n}\r\n//# sourceMappingURL=NetworkUtils.js.map","map":"{\"version\":3,\"file\":\"NetworkUtils.js\",\"sourceRoot\":\"\",\"sources\":[\"../../src/NetworkUtils.ts\"],\"names\":[],\"mappings\":\"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\",\"sourcesContent\":[\"import {setModelMetaKey, View} from 'datx';\\nimport {IDictionary} from 'datx-utils';\\nimport {fetch, Response} from 'isomorphic-fetch';\\n\\nimport {getCache, saveCache} from './cache';\\nimport {MODEL_PERSISTED_FIELD, MODEL_PROP_FIELD, MODEL_QUEUE_FIELD, MODEL_RELATED_FIELD} from './consts';\\nimport {ParamArrayType} from './enums/ParamArrayType';\\nimport {isBrowser} from './helpers/utils';\\nimport {IHeaders} from './interfaces/IHeaders';\\nimport {IJsonapiCollection} from './interfaces/IJsonapiCollection';\\nimport {IJsonapiModel} from './interfaces/IJsonapiModel';\\nimport {IRawResponse} from './interfaces/IRawResponse';\\nimport {IRequestOptions} from './interfaces/IRequestOptions';\\nimport {IResponseHeaders} from './interfaces/IResponseHeaders';\\nimport {ILink, IResponse} from './interfaces/JsonApi';\\nimport {Response as LibResponse} from './Response';\\n\\ndeclare var window: {fetch?: fetch};\\n\\nexport type FetchType = (\\n  method: string,\\n  url: string,\\n  body?: object,\\n  requestHeaders?: IHeaders,\\n) => Promise<IRawResponse>;\\n\\nexport interface ICollectionFetchOpts {\\n  url: string;\\n  options?: IRequestOptions&{headers?: IHeaders};\\n  data?: object;\\n  method: string;\\n  collection?: IJsonapiCollection;\\n  skipCache?: boolean;\\n  views?: Array<View>;\\n}\\n\\nexport type CollectionFetchType = <T extends IJsonapiModel>(options: ICollectionFetchOpts) => Promise<LibResponse<T>>;\\n\\nexport interface IResponseObject {\\n  data: IResponse;\\n  error?: Error;\\n  headers: IResponseHeaders;\\n  requestHeaders: IHeaders;\\n  status: number;\\n}\\n\\nexport interface IConfigType {\\n  baseFetch: FetchType;\\n  baseUrl: string;\\n  cache: boolean;\\n  defaultFetchOptions: IDictionary;\\n  fetchReference: fetch;\\n  paramArrayType: ParamArrayType;\\n  onError(IResponseObject): IResponseObject;\\n  transformRequest(options: ICollectionFetchOpts): ICollectionFetchOpts;\\n  transformResponse(response: IRawResponse): IRawResponse;\\n}\\n\\nexport const config: IConfigType = {\\n  // Base URL for all API calls\\n  baseUrl: '/',\\n\\n  // Enable caching by default in the browser\\n  cache: isBrowser,\\n\\n  // Default options that will be passed to the fetch function\\n  defaultFetchOptions: {\\n    headers: {\\n      'content-type': 'application/vnd.api+json',\\n    },\\n  },\\n\\n  // Reference of the fetch method that should be used\\n  fetchReference: isBrowser && 'fetch' in window && window.fetch.bind(window),\\n\\n  // Determines how will the request param arrays be stringified\\n  paramArrayType: ParamArrayType.COMMA_SEPARATED, // As recommended by the spec\\n\\n  /**\\n   * Base implementation of the fetch function (can be overridden)\\n   *\\n   * @param {string} method API call method\\n   * @param {string} url API call URL\\n   * @param {object} [body] API call body\\n   * @param {IHeaders} [requestHeaders] Headers that will be sent\\n   * @returns {Promise<IRawResponse>} Resolves with a raw response object\\n   */\\n  baseFetch(\\n    method: string,\\n    url: string,\\n    body?: object,\\n    requestHeaders?: IHeaders,\\n  ): Promise<IRawResponse> {\\n    let data: IResponse;\\n    let status: number;\\n    let headers: IResponseHeaders;\\n\\n    const request: Promise<void> = Promise.resolve();\\n\\n    const uppercaseMethod = method.toUpperCase();\\n    const isBodySupported = uppercaseMethod !== 'GET' && uppercaseMethod !== 'HEAD';\\n\\n    return request\\n      .then(() => {\\n        const defaultHeaders = config.defaultFetchOptions.headers || {};\\n        const reqHeaders: IHeaders = Object.assign({}, defaultHeaders, requestHeaders) as IHeaders;\\n        const options = Object.assign({}, config.defaultFetchOptions, {\\n          body: isBodySupported && JSON.stringify(body) || undefined,\\n          headers: reqHeaders,\\n          method,\\n        });\\n\\n        return this.fetchReference(url, options);\\n      })\\n      .then((response: Response) => {\\n        status = response.status;\\n        headers = response.headers;\\n\\n        return response.json();\\n      })\\n      .catch((error: Error) => {\\n        if (status === 204) {\\n          return null;\\n        }\\n        throw error;\\n      })\\n      .then((responseData: IResponse) => {\\n        data = responseData;\\n        if (status >= 400) {\\n          throw {\\n            message: `Invalid HTTP status: ${status}`,\\n            status,\\n          };\\n        }\\n\\n        return {data, headers, requestHeaders, status};\\n      })\\n      .catch((error) => {\\n        return this.onError({data, error, headers, requestHeaders, status});\\n      });\\n  },\\n\\n  onError(resp: IResponseObject) {\\n    return resp;\\n  },\\n\\n  transformRequest(options: ICollectionFetchOpts): ICollectionFetchOpts {\\n    return options;\\n  },\\n\\n  transformResponse(response: IRawResponse): IRawResponse {\\n    return response;\\n  },\\n};\\n\\n/**\\n * Base implementation of the stateful fetch function (can be overridden)\\n *\\n * @param {ICollectionFetchOpts} reqOptions API request options\\n * @returns {Promise<Response>} Resolves with a response object\\n */\\nfunction collectionFetch<T extends IJsonapiModel>(reqOptions: ICollectionFetchOpts): Promise<LibResponse<T>> {\\n  const {\\n    url,\\n    options,\\n    data,\\n    method = 'GET',\\n    collection,\\n    views,\\n  } = config.transformRequest(reqOptions);\\n\\n  const staticCollection = collection && collection.constructor as {cache?: boolean};\\n  const collectionCache = staticCollection && staticCollection.cache;\\n  const isCacheSupported = method.toUpperCase() === 'GET';\\n  const skipCache = reqOptions.options && reqOptions.options.skipCache;\\n\\n  if (config.cache && isCacheSupported && collectionCache && !skipCache) {\\n    const cache = getCache(url);\\n    if (cache) {\\n      return Promise.resolve(cache.response) as Promise<LibResponse<T>>;\\n    }\\n  }\\n\\n  return config.baseFetch(method, url, data, options && options.headers)\\n    .then((response: IRawResponse) => {\\n      const collectionResponse = Object.assign(response, {collection});\\n      const resp = new LibResponse<T>(\\n        config.transformResponse(collectionResponse), collection, options, undefined, views,\\n      );\\n      if (config.cache && isCacheSupported) {\\n        saveCache(url, resp);\\n      }\\n\\n      return resp;\\n    });\\n}\\n\\nexport function fetch<T extends IJsonapiModel = IJsonapiModel>(options: ICollectionFetchOpts) {\\n  return collectionFetch<T>(options);\\n}\\n\\n/**\\n * API call used to get data from the server\\n *\\n * @export\\n * @param {IJsonapiCollection} collection Related collection\\n * @param {string} url API call URL\\n * @param {IHeaders} [headers] Headers to be sent\\n * @param {IRequestOptions} [options] Server options\\n * @param {Array<View>} [views] Request view\\n * @returns {Promise<Response>} Resolves with a Response object\\n */\\nexport function read<T extends IJsonapiModel = IJsonapiModel>(\\n  url: string,\\n  collection?: IJsonapiCollection,\\n  headers?: IHeaders,\\n  options?: IRequestOptions,\\n  views?: Array<View>,\\n): Promise<LibResponse<T>> {\\n  return collectionFetch<T>({\\n    collection,\\n    data: undefined,\\n    method: 'GET',\\n    options: {...options, headers},\\n    url,\\n    views,\\n  });\\n}\\n\\n/**\\n * API call used to create data on the server\\n *\\n * @export\\n * @param {IJsonapiCollection} collection Related collection\\n * @param {string} url API call URL\\n * @param {object} [data] Request body\\n * @param {IHeaders} [headers] Headers to be sent\\n * @param {IRequestOptions} [options] Server options\\n * @param {Array<View>} [views] Request view\\n * @returns {Promise<Response>} Resolves with a Response object\\n */\\nexport function create<T extends IJsonapiModel = IJsonapiModel>(\\n  url: string,\\n  data?: object,\\n  collection?: IJsonapiCollection,\\n  headers?: IHeaders,\\n  options?: IRequestOptions,\\n  views?: Array<View>,\\n): Promise<LibResponse<T>> {\\n  return collectionFetch<T>({\\n    collection,\\n    data,\\n    method: 'POST',\\n    options: {...options, headers},\\n    url,\\n    views,\\n  });\\n}\\n\\n/**\\n * API call used to update data on the server\\n *\\n * @export\\n * @param {IJsonapiCollection} collection Related collection\\n * @param {string} url API call URL\\n * @param {object} [data] Request body\\n * @param {IHeaders} [headers] Headers to be sent\\n * @param {IRequestOptions} [options] Server options\\n * @param {Array<View>} [views] Request view\\n * @returns {Promise<Response>} Resolves with a Response object\\n */\\nexport function update<T extends IJsonapiModel = IJsonapiModel>(\\n  url: string,\\n  data?: object,\\n  collection?: IJsonapiCollection,\\n  headers?: IHeaders,\\n  options?: IRequestOptions,\\n  views?: Array<View>,\\n): Promise<LibResponse<T>> {\\n  return collectionFetch<T>({\\n    collection,\\n    data,\\n    method: 'PATCH',\\n    options: {...options, headers},\\n    url,\\n    views,\\n  });\\n}\\n\\n/**\\n * API call used to remove data from the server\\n *\\n * @export\\n * @param {IJsonapiCollection} collection Related collection\\n * @param {string} url API call URL\\n * @param {IHeaders} [headers] Headers to be sent\\n * @param {IRequestOptions} [options] Server options\\n * @param {Array<View>} [views] Request view\\n * @returns {Promise<Response>} Resolves with a Response object\\n */\\nexport function remove<T extends IJsonapiModel = IJsonapiModel>(\\n  url: string,\\n  collection?: IJsonapiCollection,\\n  headers?: IHeaders,\\n  options?: IRequestOptions,\\n  views?: Array<View>,\\n): Promise<LibResponse<T>> {\\n  return collectionFetch<T>({\\n    collection,\\n    data: undefined,\\n    method: 'DELETE',\\n    options: {...options, headers},\\n    url,\\n    views,\\n  });\\n}\\n\\n/**\\n * Fetch a link from the server\\n *\\n * @export\\n * @param {JsonApi.ILink} link Link URL or a link object\\n * @param {IJsonapiCollection} collection Store that will be used to save the response\\n * @param {IDictionary<string>} [requestHeaders] Request headers\\n * @param {IRequestOptions} [options] Server options\\n * @param {Array<View>} [views] Request view\\n * @returns {Promise<LibResponse>} Response promise\\n */\\nexport function fetchLink<T extends IJsonapiModel = IJsonapiModel>(\\n  link: ILink,\\n  collection?: IJsonapiCollection,\\n  requestHeaders?: IDictionary<string>,\\n  options?: IRequestOptions,\\n  views?: Array<View>,\\n): Promise<LibResponse<T>> {\\n  if (link) {\\n    const href: string = typeof link === 'object' ? link.href : link;\\n\\n    if (href) {\\n      return read<T>(href, collection, requestHeaders, options, views);\\n    }\\n  }\\n\\n  return Promise.resolve(new LibResponse({data: undefined}, collection));\\n}\\n\\nexport function handleResponse<T extends IJsonapiModel = IJsonapiModel>(\\n  record: T,\\n  prop?: string,\\n): (response: LibResponse<T>) => T {\\n  return (response: LibResponse<T>): T => {\\n    if (response.error) {\\n      throw response.error;\\n    }\\n\\n    if (response.status === 204) {\\n      setModelMetaKey(record, MODEL_PERSISTED_FIELD, true);\\n\\n      return record;\\n    } else if (response.status === 202) {\\n      const responseRecord = response.data as T;\\n      setModelMetaKey(responseRecord, MODEL_PROP_FIELD, prop);\\n      setModelMetaKey(responseRecord, MODEL_QUEUE_FIELD, true);\\n      setModelMetaKey(responseRecord, MODEL_RELATED_FIELD, record);\\n\\n      return responseRecord;\\n    } else {\\n      setModelMetaKey(record, MODEL_PERSISTED_FIELD, true);\\n\\n      return response.replaceData(record).data as T;\\n    }\\n  };\\n}\\n\"]}","dts":{"name":"/Users/darko/Projects/mobx/datx/packages/datx-jsonapi/NetworkUtils.d.ts","text":"import { View } from 'datx';\r\nimport { IDictionary } from 'datx-utils';\r\nimport { fetch } from 'isomorphic-fetch';\r\nimport { ParamArrayType } from './enums/ParamArrayType';\r\nimport { IHeaders } from './interfaces/IHeaders';\r\nimport { IJsonapiCollection } from './interfaces/IJsonapiCollection';\r\nimport { IJsonapiModel } from './interfaces/IJsonapiModel';\r\nimport { IRawResponse } from './interfaces/IRawResponse';\r\nimport { IRequestOptions } from './interfaces/IRequestOptions';\r\nimport { IResponseHeaders } from './interfaces/IResponseHeaders';\r\nimport { ILink, IResponse } from './interfaces/JsonApi';\r\nimport { Response as LibResponse } from './Response';\r\nexport declare type FetchType = (method: string, url: string, body?: object, requestHeaders?: IHeaders) => Promise<IRawResponse>;\r\nexport interface ICollectionFetchOpts {\r\n    url: string;\r\n    options?: IRequestOptions & {\r\n        headers?: IHeaders;\r\n    };\r\n    data?: object;\r\n    method: string;\r\n    collection?: IJsonapiCollection;\r\n    skipCache?: boolean;\r\n    views?: Array<View>;\r\n}\r\nexport declare type CollectionFetchType = <T extends IJsonapiModel>(options: ICollectionFetchOpts) => Promise<LibResponse<T>>;\r\nexport interface IResponseObject {\r\n    data: IResponse;\r\n    error?: Error;\r\n    headers: IResponseHeaders;\r\n    requestHeaders: IHeaders;\r\n    status: number;\r\n}\r\nexport interface IConfigType {\r\n    baseFetch: FetchType;\r\n    baseUrl: string;\r\n    cache: boolean;\r\n    defaultFetchOptions: IDictionary;\r\n    fetchReference: fetch;\r\n    paramArrayType: ParamArrayType;\r\n    onError(IResponseObject: any): IResponseObject;\r\n    transformRequest(options: ICollectionFetchOpts): ICollectionFetchOpts;\r\n    transformResponse(response: IRawResponse): IRawResponse;\r\n}\r\nexport declare const config: IConfigType;\r\nexport declare function fetch<T extends IJsonapiModel = IJsonapiModel>(options: ICollectionFetchOpts): Promise<LibResponse<T>>;\r\n/**\r\n * API call used to get data from the server\r\n *\r\n * @export\r\n * @param {IJsonapiCollection} collection Related collection\r\n * @param {string} url API call URL\r\n * @param {IHeaders} [headers] Headers to be sent\r\n * @param {IRequestOptions} [options] Server options\r\n * @param {Array<View>} [views] Request view\r\n * @returns {Promise<Response>} Resolves with a Response object\r\n */\r\nexport declare function read<T extends IJsonapiModel = IJsonapiModel>(url: string, collection?: IJsonapiCollection, headers?: IHeaders, options?: IRequestOptions, views?: Array<View>): Promise<LibResponse<T>>;\r\n/**\r\n * API call used to create data on the server\r\n *\r\n * @export\r\n * @param {IJsonapiCollection} collection Related collection\r\n * @param {string} url API call URL\r\n * @param {object} [data] Request body\r\n * @param {IHeaders} [headers] Headers to be sent\r\n * @param {IRequestOptions} [options] Server options\r\n * @param {Array<View>} [views] Request view\r\n * @returns {Promise<Response>} Resolves with a Response object\r\n */\r\nexport declare function create<T extends IJsonapiModel = IJsonapiModel>(url: string, data?: object, collection?: IJsonapiCollection, headers?: IHeaders, options?: IRequestOptions, views?: Array<View>): Promise<LibResponse<T>>;\r\n/**\r\n * API call used to update data on the server\r\n *\r\n * @export\r\n * @param {IJsonapiCollection} collection Related collection\r\n * @param {string} url API call URL\r\n * @param {object} [data] Request body\r\n * @param {IHeaders} [headers] Headers to be sent\r\n * @param {IRequestOptions} [options] Server options\r\n * @param {Array<View>} [views] Request view\r\n * @returns {Promise<Response>} Resolves with a Response object\r\n */\r\nexport declare function update<T extends IJsonapiModel = IJsonapiModel>(url: string, data?: object, collection?: IJsonapiCollection, headers?: IHeaders, options?: IRequestOptions, views?: Array<View>): Promise<LibResponse<T>>;\r\n/**\r\n * API call used to remove data from the server\r\n *\r\n * @export\r\n * @param {IJsonapiCollection} collection Related collection\r\n * @param {string} url API call URL\r\n * @param {IHeaders} [headers] Headers to be sent\r\n * @param {IRequestOptions} [options] Server options\r\n * @param {Array<View>} [views] Request view\r\n * @returns {Promise<Response>} Resolves with a Response object\r\n */\r\nexport declare function remove<T extends IJsonapiModel = IJsonapiModel>(url: string, collection?: IJsonapiCollection, headers?: IHeaders, options?: IRequestOptions, views?: Array<View>): Promise<LibResponse<T>>;\r\n/**\r\n * Fetch a link from the server\r\n *\r\n * @export\r\n * @param {JsonApi.ILink} link Link URL or a link object\r\n * @param {IJsonapiCollection} collection Store that will be used to save the response\r\n * @param {IDictionary<string>} [requestHeaders] Request headers\r\n * @param {IRequestOptions} [options] Server options\r\n * @param {Array<View>} [views] Request view\r\n * @returns {Promise<LibResponse>} Response promise\r\n */\r\nexport declare function fetchLink<T extends IJsonapiModel = IJsonapiModel>(link: ILink, collection?: IJsonapiCollection, requestHeaders?: IDictionary<string>, options?: IRequestOptions, views?: Array<View>): Promise<LibResponse<T>>;\r\nexport declare function handleResponse<T extends IJsonapiModel = IJsonapiModel>(record: T, prop?: string): (response: LibResponse<T>) => T;\r\n"}}

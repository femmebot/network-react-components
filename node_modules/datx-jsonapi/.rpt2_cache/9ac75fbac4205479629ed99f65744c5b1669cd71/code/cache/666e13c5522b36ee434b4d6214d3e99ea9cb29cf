{"code":"import * as tslib_1 from \"tslib\";\r\nimport { setModelMetaKey } from 'datx';\r\nimport { getCache, saveCache } from './cache';\r\nimport { MODEL_PERSISTED_FIELD, MODEL_PROP_FIELD, MODEL_QUEUE_FIELD, MODEL_RELATED_FIELD } from './consts';\r\nimport { ParamArrayType } from './enums/ParamArrayType';\r\nimport { isBrowser } from './helpers/utils';\r\nimport { Response as LibResponse } from './Response';\r\nexport var config = {\r\n    // Base URL for all API calls\r\n    baseUrl: '/',\r\n    // Enable caching by default in the browser\r\n    cache: isBrowser,\r\n    // Default options that will be passed to the fetch function\r\n    defaultFetchOptions: {\r\n        headers: {\r\n            'content-type': 'application/vnd.api+json',\r\n        },\r\n    },\r\n    // Reference of the fetch method that should be used\r\n    fetchReference: isBrowser && 'fetch' in window && window.fetch.bind(window),\r\n    // Determines how will the request param arrays be stringified\r\n    paramArrayType: ParamArrayType.COMMA_SEPARATED,\r\n    /**\r\n     * Base implementation of the fetch function (can be overridden)\r\n     *\r\n     * @param {string} method API call method\r\n     * @param {string} url API call URL\r\n     * @param {object} [body] API call body\r\n     * @param {IHeaders} [requestHeaders] Headers that will be sent\r\n     * @returns {Promise<IRawResponse>} Resolves with a raw response object\r\n     */\r\n    baseFetch: function (method, url, body, requestHeaders) {\r\n        var _this = this;\r\n        var data;\r\n        var status;\r\n        var headers;\r\n        var request = Promise.resolve();\r\n        var uppercaseMethod = method.toUpperCase();\r\n        var isBodySupported = uppercaseMethod !== 'GET' && uppercaseMethod !== 'HEAD';\r\n        return request\r\n            .then(function () {\r\n            var defaultHeaders = config.defaultFetchOptions.headers || {};\r\n            var reqHeaders = Object.assign({}, defaultHeaders, requestHeaders);\r\n            var options = Object.assign({}, config.defaultFetchOptions, {\r\n                body: isBodySupported && JSON.stringify(body) || undefined,\r\n                headers: reqHeaders,\r\n                method: method,\r\n            });\r\n            return _this.fetchReference(url, options);\r\n        })\r\n            .then(function (response) {\r\n            status = response.status;\r\n            headers = response.headers;\r\n            return response.json();\r\n        })\r\n            .catch(function (error) {\r\n            if (status === 204) {\r\n                return null;\r\n            }\r\n            throw error;\r\n        })\r\n            .then(function (responseData) {\r\n            data = responseData;\r\n            if (status >= 400) {\r\n                throw {\r\n                    message: \"Invalid HTTP status: \" + status,\r\n                    status: status,\r\n                };\r\n            }\r\n            return { data: data, headers: headers, requestHeaders: requestHeaders, status: status };\r\n        })\r\n            .catch(function (error) {\r\n            return _this.onError({ data: data, error: error, headers: headers, requestHeaders: requestHeaders, status: status });\r\n        });\r\n    },\r\n    onError: function (resp) {\r\n        return resp;\r\n    },\r\n    transformRequest: function (options) {\r\n        return options;\r\n    },\r\n    transformResponse: function (response) {\r\n        return response;\r\n    },\r\n};\r\n/**\r\n * Base implementation of the stateful fetch function (can be overridden)\r\n *\r\n * @param {ICollectionFetchOpts} reqOptions API request options\r\n * @returns {Promise<Response>} Resolves with a response object\r\n */\r\nfunction collectionFetch(reqOptions) {\r\n    var _a = config.transformRequest(reqOptions), url = _a.url, options = _a.options, data = _a.data, _b = _a.method, method = _b === void 0 ? 'GET' : _b, collection = _a.collection, views = _a.views;\r\n    var staticCollection = collection && collection.constructor;\r\n    var collectionCache = staticCollection && staticCollection.cache;\r\n    var isCacheSupported = method.toUpperCase() === 'GET';\r\n    var skipCache = reqOptions.options && reqOptions.options.skipCache;\r\n    if (config.cache && isCacheSupported && collectionCache && !skipCache) {\r\n        var cache = getCache(url);\r\n        if (cache) {\r\n            return Promise.resolve(cache.response);\r\n        }\r\n    }\r\n    return config.baseFetch(method, url, data, options && options.headers)\r\n        .then(function (response) {\r\n        var collectionResponse = Object.assign(response, { collection: collection });\r\n        var resp = new LibResponse(config.transformResponse(collectionResponse), collection, options, undefined, views);\r\n        if (config.cache && isCacheSupported) {\r\n            saveCache(url, resp);\r\n        }\r\n        return resp;\r\n    });\r\n}\r\nexport function fetch(options) {\r\n    return collectionFetch(options);\r\n}\r\n/**\r\n * API call used to get data from the server\r\n *\r\n * @export\r\n * @param {IJsonapiCollection} collection Related collection\r\n * @param {string} url API call URL\r\n * @param {IHeaders} [headers] Headers to be sent\r\n * @param {IRequestOptions} [options] Server options\r\n * @param {Array<View>} [views] Request view\r\n * @returns {Promise<Response>} Resolves with a Response object\r\n */\r\nexport function read(url, collection, headers, options, views) {\r\n    return collectionFetch({\r\n        collection: collection,\r\n        data: undefined,\r\n        method: 'GET',\r\n        options: tslib_1.__assign({}, options, { headers: headers }),\r\n        url: url,\r\n        views: views,\r\n    });\r\n}\r\n/**\r\n * API call used to create data on the server\r\n *\r\n * @export\r\n * @param {IJsonapiCollection} collection Related collection\r\n * @param {string} url API call URL\r\n * @param {object} [data] Request body\r\n * @param {IHeaders} [headers] Headers to be sent\r\n * @param {IRequestOptions} [options] Server options\r\n * @param {Array<View>} [views] Request view\r\n * @returns {Promise<Response>} Resolves with a Response object\r\n */\r\nexport function create(url, data, collection, headers, options, views) {\r\n    return collectionFetch({\r\n        collection: collection,\r\n        data: data,\r\n        method: 'POST',\r\n        options: tslib_1.__assign({}, options, { headers: headers }),\r\n        url: url,\r\n        views: views,\r\n    });\r\n}\r\n/**\r\n * API call used to update data on the server\r\n *\r\n * @export\r\n * @param {IJsonapiCollection} collection Related collection\r\n * @param {string} url API call URL\r\n * @param {object} [data] Request body\r\n * @param {IHeaders} [headers] Headers to be sent\r\n * @param {IRequestOptions} [options] Server options\r\n * @param {Array<View>} [views] Request view\r\n * @returns {Promise<Response>} Resolves with a Response object\r\n */\r\nexport function update(url, data, collection, headers, options, views) {\r\n    return collectionFetch({\r\n        collection: collection,\r\n        data: data,\r\n        method: 'PATCH',\r\n        options: tslib_1.__assign({}, options, { headers: headers }),\r\n        url: url,\r\n        views: views,\r\n    });\r\n}\r\n/**\r\n * API call used to remove data from the server\r\n *\r\n * @export\r\n * @param {IJsonapiCollection} collection Related collection\r\n * @param {string} url API call URL\r\n * @param {IHeaders} [headers] Headers to be sent\r\n * @param {IRequestOptions} [options] Server options\r\n * @param {Array<View>} [views] Request view\r\n * @returns {Promise<Response>} Resolves with a Response object\r\n */\r\nexport function remove(url, collection, headers, options, views) {\r\n    return collectionFetch({\r\n        collection: collection,\r\n        data: undefined,\r\n        method: 'DELETE',\r\n        options: tslib_1.__assign({}, options, { headers: headers }),\r\n        url: url,\r\n        views: views,\r\n    });\r\n}\r\n/**\r\n * Fetch a link from the server\r\n *\r\n * @export\r\n * @param {JsonApi.ILink} link Link URL or a link object\r\n * @param {IJsonapiCollection} collection Store that will be used to save the response\r\n * @param {IDictionary<string>} [requestHeaders] Request headers\r\n * @param {IRequestOptions} [options] Server options\r\n * @param {Array<View>} [views] Request view\r\n * @returns {Promise<LibResponse>} Response promise\r\n */\r\nexport function fetchLink(link, collection, requestHeaders, options, views) {\r\n    if (link) {\r\n        var href = typeof link === 'object' ? link.href : link;\r\n        if (href) {\r\n            return read(href, collection, requestHeaders, options, views);\r\n        }\r\n    }\r\n    return Promise.resolve(new LibResponse({ data: undefined }, collection));\r\n}\r\nexport function handleResponse(record, prop) {\r\n    return function (response) {\r\n        if (response.error) {\r\n            throw response.error;\r\n        }\r\n        if (response.status === 204) {\r\n            setModelMetaKey(record, MODEL_PERSISTED_FIELD, true);\r\n            return record;\r\n        }\r\n        else if (response.status === 202) {\r\n            var responseRecord = response.data;\r\n            setModelMetaKey(responseRecord, MODEL_PROP_FIELD, prop);\r\n            setModelMetaKey(responseRecord, MODEL_QUEUE_FIELD, true);\r\n            setModelMetaKey(responseRecord, MODEL_RELATED_FIELD, record);\r\n            return responseRecord;\r\n        }\r\n        else {\r\n            setModelMetaKey(record, MODEL_PERSISTED_FIELD, true);\r\n            return response.replaceData(record).data;\r\n        }\r\n    };\r\n}\r\n","dts":{"name":"/Users/darko/Projects/mobx/datx/packages/datx-jsonapi/NetworkUtils.d.ts","text":"import { View } from 'datx';\r\nimport { IDictionary } from 'datx-utils';\r\nimport { fetch } from 'isomorphic-fetch';\r\nimport { ParamArrayType } from './enums/ParamArrayType';\r\nimport { IHeaders } from './interfaces/IHeaders';\r\nimport { IJsonapiCollection } from './interfaces/IJsonapiCollection';\r\nimport { IJsonapiModel } from './interfaces/IJsonapiModel';\r\nimport { IRawResponse } from './interfaces/IRawResponse';\r\nimport { IRequestOptions } from './interfaces/IRequestOptions';\r\nimport { IResponseHeaders } from './interfaces/IResponseHeaders';\r\nimport { ILink, IResponse } from './interfaces/JsonApi';\r\nimport { Response as LibResponse } from './Response';\r\nexport declare type FetchType = (method: string, url: string, body?: object, requestHeaders?: IHeaders) => Promise<IRawResponse>;\r\nexport interface ICollectionFetchOpts {\r\n    url: string;\r\n    options?: IRequestOptions & {\r\n        headers?: IHeaders;\r\n    };\r\n    data?: object;\r\n    method: string;\r\n    collection?: IJsonapiCollection;\r\n    skipCache?: boolean;\r\n    views?: Array<View>;\r\n}\r\nexport declare type CollectionFetchType = <T extends IJsonapiModel>(options: ICollectionFetchOpts) => Promise<LibResponse<T>>;\r\nexport interface IResponseObject {\r\n    data: IResponse;\r\n    error?: Error;\r\n    headers: IResponseHeaders;\r\n    requestHeaders: IHeaders;\r\n    status: number;\r\n}\r\nexport interface IConfigType {\r\n    baseFetch: FetchType;\r\n    baseUrl: string;\r\n    cache: boolean;\r\n    defaultFetchOptions: IDictionary;\r\n    fetchReference: fetch;\r\n    paramArrayType: ParamArrayType;\r\n    onError(IResponseObject: any): IResponseObject;\r\n    transformRequest(options: ICollectionFetchOpts): ICollectionFetchOpts;\r\n    transformResponse(response: IRawResponse): IRawResponse;\r\n}\r\nexport declare const config: IConfigType;\r\nexport declare function fetch<T extends IJsonapiModel = IJsonapiModel>(options: ICollectionFetchOpts): Promise<LibResponse<T>>;\r\n/**\r\n * API call used to get data from the server\r\n *\r\n * @export\r\n * @param {IJsonapiCollection} collection Related collection\r\n * @param {string} url API call URL\r\n * @param {IHeaders} [headers] Headers to be sent\r\n * @param {IRequestOptions} [options] Server options\r\n * @param {Array<View>} [views] Request view\r\n * @returns {Promise<Response>} Resolves with a Response object\r\n */\r\nexport declare function read<T extends IJsonapiModel = IJsonapiModel>(url: string, collection?: IJsonapiCollection, headers?: IHeaders, options?: IRequestOptions, views?: Array<View>): Promise<LibResponse<T>>;\r\n/**\r\n * API call used to create data on the server\r\n *\r\n * @export\r\n * @param {IJsonapiCollection} collection Related collection\r\n * @param {string} url API call URL\r\n * @param {object} [data] Request body\r\n * @param {IHeaders} [headers] Headers to be sent\r\n * @param {IRequestOptions} [options] Server options\r\n * @param {Array<View>} [views] Request view\r\n * @returns {Promise<Response>} Resolves with a Response object\r\n */\r\nexport declare function create<T extends IJsonapiModel = IJsonapiModel>(url: string, data?: object, collection?: IJsonapiCollection, headers?: IHeaders, options?: IRequestOptions, views?: Array<View>): Promise<LibResponse<T>>;\r\n/**\r\n * API call used to update data on the server\r\n *\r\n * @export\r\n * @param {IJsonapiCollection} collection Related collection\r\n * @param {string} url API call URL\r\n * @param {object} [data] Request body\r\n * @param {IHeaders} [headers] Headers to be sent\r\n * @param {IRequestOptions} [options] Server options\r\n * @param {Array<View>} [views] Request view\r\n * @returns {Promise<Response>} Resolves with a Response object\r\n */\r\nexport declare function update<T extends IJsonapiModel = IJsonapiModel>(url: string, data?: object, collection?: IJsonapiCollection, headers?: IHeaders, options?: IRequestOptions, views?: Array<View>): Promise<LibResponse<T>>;\r\n/**\r\n * API call used to remove data from the server\r\n *\r\n * @export\r\n * @param {IJsonapiCollection} collection Related collection\r\n * @param {string} url API call URL\r\n * @param {IHeaders} [headers] Headers to be sent\r\n * @param {IRequestOptions} [options] Server options\r\n * @param {Array<View>} [views] Request view\r\n * @returns {Promise<Response>} Resolves with a Response object\r\n */\r\nexport declare function remove<T extends IJsonapiModel = IJsonapiModel>(url: string, collection?: IJsonapiCollection, headers?: IHeaders, options?: IRequestOptions, views?: Array<View>): Promise<LibResponse<T>>;\r\n/**\r\n * Fetch a link from the server\r\n *\r\n * @export\r\n * @param {JsonApi.ILink} link Link URL or a link object\r\n * @param {IJsonapiCollection} collection Store that will be used to save the response\r\n * @param {IDictionary<string>} [requestHeaders] Request headers\r\n * @param {IRequestOptions} [options] Server options\r\n * @param {Array<View>} [views] Request view\r\n * @returns {Promise<LibResponse>} Response promise\r\n */\r\nexport declare function fetchLink<T extends IJsonapiModel = IJsonapiModel>(link: ILink, collection?: IJsonapiCollection, requestHeaders?: IDictionary<string>, options?: IRequestOptions, views?: Array<View>): Promise<LibResponse<T>>;\r\nexport declare function handleResponse<T extends IJsonapiModel = IJsonapiModel>(record: T, prop?: string): (response: LibResponse<T>) => T;\r\n"}}

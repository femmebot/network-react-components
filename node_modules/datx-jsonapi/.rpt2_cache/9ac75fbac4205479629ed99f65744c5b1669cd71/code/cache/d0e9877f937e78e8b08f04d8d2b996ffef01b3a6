{"code":"import * as tslib_1 from \"tslib\";\r\nimport { getModelCollection, getModelId, getModelMetaKey, getModelType, getRefId, modelToJSON, ReferenceType, setModelMetaKey, } from 'datx';\r\nimport { mapItems, META_FIELD } from 'datx-utils';\r\nimport { isObservableArray } from 'mobx';\r\nimport { clearCacheByType } from '../cache';\r\nimport { MODEL_LINKS_FIELD, MODEL_META_FIELD, MODEL_PERSISTED_FIELD, MODEL_PROP_FIELD, MODEL_QUEUE_FIELD, MODEL_REF_LINKS_FIELD, MODEL_REF_META_FIELD, MODEL_RELATED_FIELD, } from '../consts';\r\nimport { config, create, fetchLink, handleResponse, remove, update } from '../NetworkUtils';\r\nimport { getValue } from './utils';\r\nexport function flattenModel(data) {\r\n    if (!data) {\r\n        return null;\r\n    }\r\n    var rawData = (_a = {},\r\n        _a[META_FIELD] = (_b = {\r\n                fields: Object.keys(data.attributes),\r\n                id: data.id\r\n            },\r\n            _b[MODEL_LINKS_FIELD] = data.links,\r\n            _b[MODEL_META_FIELD] = data.meta,\r\n            _b[MODEL_PERSISTED_FIELD] = Boolean(data.id),\r\n            _b.refs = {},\r\n            _b.type = data.type,\r\n            _b),\r\n        _a);\r\n    if (data.relationships) {\r\n        var refLinks_1 = {};\r\n        var refMeta_1 = {};\r\n        var refs_1 = {};\r\n        Object.keys(data.relationships).forEach(function (key) {\r\n            var ref = data.relationships[key];\r\n            if ('data' in ref && ref.data && (!(ref.data instanceof Array) || ref.data.length > 0)) {\r\n                rawData[key] = mapItems(ref.data, function (item) { return item.id; });\r\n                refs_1[key] = {\r\n                    model: ref.data instanceof Array ? ref.data[0].type : ref.data.type,\r\n                    type: ref.data instanceof Array ? ReferenceType.TO_MANY : ReferenceType.TO_ONE,\r\n                };\r\n            }\r\n            if ('links' in ref) {\r\n                refLinks_1[key] = ref.links;\r\n            }\r\n            if ('meta' in ref) {\r\n                refMeta_1[key] = ref.meta;\r\n            }\r\n        });\r\n        rawData[META_FIELD].refs = refs_1;\r\n        rawData[META_FIELD][MODEL_REF_LINKS_FIELD] = refLinks_1;\r\n        rawData[META_FIELD][MODEL_REF_META_FIELD] = refMeta_1;\r\n    }\r\n    return Object.assign(rawData, data.attributes);\r\n    var _a, _b;\r\n}\r\nexport function getModelMeta(model) {\r\n    return getModelMetaKey(model, MODEL_META_FIELD);\r\n}\r\nexport function getModelLinks(model) {\r\n    return getModelMetaKey(model, MODEL_LINKS_FIELD);\r\n}\r\nexport function fetchModelLink(model, key, requestHeaders, options) {\r\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n        var collection, links, link, responseObj;\r\n        return tslib_1.__generator(this, function (_a) {\r\n            collection = getModelCollection(model);\r\n            links = getModelLinks(model);\r\n            if (!(key in links)) {\r\n                throw new Error(\"Link \" + key + \" doesn't exist on the model\");\r\n            }\r\n            link = links[key];\r\n            responseObj = fetchLink(link, collection, requestHeaders, options);\r\n            if (getModelMetaKey(model, MODEL_QUEUE_FIELD)) {\r\n                return [2 /*return*/, responseObj.then(function (response) {\r\n                        var related = getModelMetaKey(model, MODEL_RELATED_FIELD);\r\n                        var prop = getModelMetaKey(model, MODEL_PROP_FIELD);\r\n                        var record = response.data;\r\n                        var recordType = record && getModelType(record);\r\n                        if (record && recordType !== getModelType(model) && recordType === getModelType(related)) {\r\n                            if (prop) {\r\n                                related[prop] = record;\r\n                                return response;\r\n                            }\r\n                            setModelMetaKey(related, MODEL_PERSISTED_FIELD, true);\r\n                            return response.replaceData(related);\r\n                        }\r\n                        return response;\r\n                    })];\r\n            }\r\n            return [2 /*return*/, responseObj];\r\n        });\r\n    });\r\n}\r\nfunction getLink(model, ref, key) {\r\n    var collection = getModelCollection(model);\r\n    if (!collection) {\r\n        throw new Error('The model needs to be in a collection');\r\n    }\r\n    var links = getModelRefLinks(model);\r\n    if (!(ref in links)) {\r\n        throw new Error(\"The reference \" + ref + \" doesn't have any links\");\r\n    }\r\n    var refLinks = links[ref];\r\n    if (!(key in refLinks)) {\r\n        throw new Error(\"Link \" + key + \" doesn't exist on the model\");\r\n    }\r\n    return refLinks[key];\r\n}\r\nexport function fetchModelRefLink(model, ref, key, requestHeaders, options) {\r\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n        var collection, link;\r\n        return tslib_1.__generator(this, function (_a) {\r\n            collection = getModelCollection(model);\r\n            link = getLink(model, ref, key);\r\n            return [2 /*return*/, fetchLink(link, collection, requestHeaders, options)];\r\n        });\r\n    });\r\n}\r\nexport function getModelRefLinks(model) {\r\n    return getModelMetaKey(model, MODEL_REF_LINKS_FIELD);\r\n}\r\nexport function getModelRefMeta(model) {\r\n    return getModelMetaKey(model, MODEL_REF_META_FIELD);\r\n}\r\nfunction isModelPersisted(model) {\r\n    return getModelMetaKey(model, MODEL_PERSISTED_FIELD);\r\n}\r\nfunction setModelPersisted(model, status) {\r\n    setModelMetaKey(model, MODEL_PERSISTED_FIELD, status);\r\n}\r\nexport function modelToJsonApi(model) {\r\n    var staticModel = model.constructor;\r\n    var attributes = modelToJSON(model);\r\n    var useAutogenerated = staticModel['useAutogeneratedIds'];\r\n    var isPersisted = isModelPersisted(model);\r\n    var data = {\r\n        attributes: attributes,\r\n        id: (isPersisted || useAutogenerated) ? getModelId(model) : undefined,\r\n        type: getModelType(model),\r\n    };\r\n    var refs = getModelMetaKey(model, 'refs');\r\n    Object.keys(refs).forEach(function (key) {\r\n        data.relationships = data.relationships || {};\r\n        var refIds = getRefId(model, key);\r\n        var rel;\r\n        if (refIds instanceof Array || isObservableArray(refIds)) {\r\n            rel = refIds.map(function (id, index) {\r\n                var type = model[key][index] ? getModelType(model[key][index]) : refs[key].model;\r\n                return { id: id, type: type };\r\n            });\r\n        }\r\n        else {\r\n            var type = model[key] ? getModelType(model[key]) : refs[key].model;\r\n            rel = refIds ? { id: refIds, type: type } : undefined;\r\n        }\r\n        data.relationships[key] = { data: rel };\r\n        delete data.attributes[key];\r\n    });\r\n    delete data.attributes.id;\r\n    delete data.attributes[META_FIELD];\r\n    return data;\r\n}\r\nfunction getModelEndpointUrl(model) {\r\n    var staticModel = model.constructor;\r\n    var links = getModelLinks(model);\r\n    if (links && links.self) {\r\n        var self = links.self;\r\n        return typeof self === 'string' ? self : self.href;\r\n    }\r\n    var url = getValue(staticModel['endpoint']) || getModelType(model);\r\n    return isModelPersisted(model)\r\n        ? \"\" + config.baseUrl + url + \"/\" + getModelId(model)\r\n        : \"\" + config.baseUrl + url;\r\n}\r\nexport function saveModel(model, options) {\r\n    var collection = getModelCollection(model);\r\n    var data = modelToJsonApi(model);\r\n    var requestMethod = isModelPersisted(model) ? update : create;\r\n    var url = getModelEndpointUrl(model);\r\n    return requestMethod(url, { data: data }, collection, options && options.headers)\r\n        .then(handleResponse(model))\r\n        .then(function (response) {\r\n        clearCacheByType(getModelType(model));\r\n        return response;\r\n    });\r\n}\r\nexport function removeModel(model, options) {\r\n    var collection = getModelCollection(model);\r\n    var isPersisted = isModelPersisted(model);\r\n    var url = getModelEndpointUrl(model);\r\n    if (isPersisted) {\r\n        return remove(url, collection, options && options.headers)\r\n            .then(function (response) {\r\n            if (response.error) {\r\n                throw response.error;\r\n            }\r\n            setModelPersisted(model, false);\r\n            if (collection) {\r\n                collection.remove(model);\r\n            }\r\n        });\r\n    }\r\n    else if (collection) {\r\n        collection.remove(model);\r\n    }\r\n    return Promise.resolve();\r\n}\r\nexport function saveRelationship(model, ref, options) {\r\n    var collection = getModelCollection(model);\r\n    var link = getLink(model, ref, 'self');\r\n    var href = typeof link === 'object' ? link.href : link;\r\n    var ids = getRefId(model, ref);\r\n    var type = getModelType(getModelMetaKey(model, 'refs')[ref].model);\r\n    var data = mapItems(ids, function (id) { return ({ id: id, type: type }); });\r\n    return update(href, { data: data }, collection, options && options.headers)\r\n        .then(handleResponse(model, ref));\r\n}\r\n","dts":{"name":"/Users/darko/Projects/mobx/datx/packages/datx-jsonapi/helpers/model.d.ts","text":"import { PureModel } from 'datx';\r\nimport { IDictionary, IRawModel } from 'datx-utils';\r\nimport { IJsonapiModel } from '../interfaces/IJsonapiModel';\r\nimport { IRequestOptions } from '../interfaces/IRequestOptions';\r\nimport { ILink, IRecord } from '../interfaces/JsonApi';\r\nimport { Response } from '../Response';\r\nexport declare function flattenModel(): null;\r\nexport declare function flattenModel(data?: IRecord): IRawModel;\r\nexport declare function getModelMeta(model: PureModel): IDictionary;\r\nexport declare function getModelLinks(model: PureModel): IDictionary<ILink>;\r\nexport declare function fetchModelLink<T extends IJsonapiModel = IJsonapiModel>(model: PureModel, key: string, requestHeaders?: IDictionary<string>, options?: IRequestOptions): Promise<Response<T>>;\r\nexport declare function fetchModelRefLink<T extends IJsonapiModel = IJsonapiModel>(model: PureModel, ref: string, key: string, requestHeaders?: IDictionary<string>, options?: IRequestOptions): Promise<Response<T>>;\r\nexport declare function getModelRefLinks(model: PureModel): IDictionary<IDictionary<ILink>>;\r\nexport declare function getModelRefMeta(model: PureModel): IDictionary;\r\nexport declare function modelToJsonApi(model: IJsonapiModel): IRecord;\r\nexport declare function saveModel(model: IJsonapiModel, options?: IRequestOptions): Promise<IJsonapiModel>;\r\nexport declare function removeModel<T extends IJsonapiModel>(model: T, options?: IRequestOptions): Promise<void>;\r\nexport declare function saveRelationship<T extends IJsonapiModel>(model: T, ref: string, options?: IRequestOptions): Promise<T>;\r\n"}}
